use compact_str::CompactString;
use regex::Regex;
use lazy_static::lazy_static;
use std::collections::HashMap;

lazy_static! {
    static ref SEQ_REGEX: Regex = Regex::new(r".*(DFF|DHL|DLL|ICG|SDF).*").unwrap();
}

/// standard cell celltype numerical attributes, and cell pin type numerical attributes
///
/// The GATSPI simulator uses this. Celltype number corresponds to 
/// row in logic truth table that houses truth tables for all cells
/// used in constructing NetlistDB.
///
/// pin type number tells simulator which pin connection the simulation graph
/// edge connection is representing.
///

pub trait StandardCellTypeAttribute {
    /// This function is called from GATSPIGraph constructor to
    /// provide standard cell celltype attribute to the GATSPI
    /// simulation graph
    fn get_celltype(
        &self,
        macro_name: &CompactString, pin_name: &CompactString, top_name: &CompactString,
    ) -> u16;

    // pin type attribute
    fn get_pintype(
        &self,
        macro_name: &CompactString,
        pin_name: &CompactString
    ) -> u8;
}

lazy_static! {
    pub static ref celltypeHash: HashMap<&'static str, u16> =  HashMap::from([
("A2O1A1I",0),
("A2O1A1O1I",1),
("AO211",  2),
("AO21",   3),
("AO221",  4),
("AO222",  5),
("AO22",   6),
("AO31",   7),
("AO322",  8),
("AO32",   9),
("AO331",  10),
("AO332",  11),
("AO333",  12),
("AO33",   13),
("AOI211", 14),
("AOI21",  15),
("AOI221", 16),
("AOI222", 17),
("AOI22",  18),
("AOI311", 19),
("AOI31",  20),
("AOI321", 21),
("AOI322", 22),
("AOI32",  23),
("AOI331", 24),
("AOI332", 25),
("AOI333", 26),
("AOI33",  27),
("BUF",    28),
("CKINVDC",29),
("HB1",    30),
("HB2",    31),
("HB3",    32),
("HB4",    33),
("INV",    34),
("O2A1O1I",35),
("OA211",  36),
("OA21",   37),
("OA221",  38),
("OA222",  39),
("OA22",   40),
("OA31",   41),
("OA331",  42),
("OA332",  43),
("OA333",  44),
("OA33",   45),
("OAI211", 46),
("OAI21",  47),
("OAI221", 48),
("OAI222", 49),
("OAI22",  50),
("OAI311", 51),
("OAI31",  52),
("OAI321", 53),
("OAI322", 54),
("OAI32",  55),
("OAI331", 56),
("OAI332", 57),
("OAI333", 58),
("OAI33",  59),
("AND2",   60),
("AND3",   61),
("AND4",   62),
("AND5",   63),
("FASN",     64),
("FACON",     65),
("HASN",     66),
("HACON",     67),
("MAJI",   68),
("MAJ",    69),
("NAND2",  70),
("NAND3",  71),
("NAND4",  72),
("NAND5",  73),
("NOR2",   74),
("NOR3",   75),
("NOR4",   76),
("NOR5",   77),
("OR2",    78),
("OR3",    79),
("OR4",    80),
("OR5",    81),
("XNOR2",  82),
("XOR2",   83),
]);
}

lazy_static! {
 pub static ref pintypeHash: HashMap<&'static str, u8> =  HashMap::from([
  ("A2O1A1I/A1", 3),
  ("A2O1A1I/A2", 2),
  ("A2O1A1I/B", 1),
  ("A2O1A1I/C", 0),
  ("A2O1A1O1I/A1", 4),
  ("A2O1A1O1I/A2", 3),
  ("A2O1A1O1I/B", 2),
  ("A2O1A1O1I/C", 1),
  ("A2O1A1O1I/D", 0),
  ("AO211/A1", 3),
  ("AO211/A2", 2),
  ("AO211/B", 1),
  ("AO211/C", 0),
  ("AO21/A1", 2),
  ("AO21/A2", 1),
  ("AO21/B", 0),
  ("AO221/A1", 4),
  ("AO221/A2", 3),
  ("AO221/B1", 2),
  ("AO221/B2", 1),
  ("AO221/C", 0),
  ("AO222/A1", 5),
  ("AO222/A2", 4),
  ("AO222/B1", 3),
  ("AO222/B2", 2),
  ("AO222/C1", 1),
  ("AO222/C2", 0),
  ("AO22/A1", 3),
  ("AO22/A2", 2),
  ("AO22/B1", 1),
  ("AO22/B2", 0),
  ("AO31/A1", 3),
  ("AO31/A2", 2),
  ("AO31/A3", 1),
  ("AO31/B", 0),
  ("AO322/A1", 6),
  ("AO322/A2", 5),
  ("AO322/A3", 4),
  ("AO322/B1", 3),
  ("AO322/B2", 2),
  ("AO322/C1", 1),
  ("AO322/C2", 0),
  ("AO32/A1", 4),
  ("AO32/A2", 3),
  ("AO32/A3", 2),
  ("AO32/B1", 1),
  ("AO32/B2", 0),
  ("AO331/A1", 6),
  ("AO331/A2", 5),
  ("AO331/A3", 4),
  ("AO331/B1", 3),
  ("AO331/B2", 2),
  ("AO331/B3", 1),
  ("AO331/C", 0),
  ("AO332/A1", 7),
  ("AO332/A2", 6),
  ("AO332/A3", 5),
  ("AO332/B1", 4),
  ("AO332/B2", 3),
  ("AO332/B3", 2),
  ("AO332/C1", 1),
  ("AO332/C2", 0),
  ("AO333/A1", 8),
  ("AO333/A2", 7),
  ("AO333/A3", 6),
  ("AO333/B1", 5),
  ("AO333/B2", 4),
  ("AO333/B3", 3),
  ("AO333/C1", 2),
  ("AO333/C2", 1),
  ("AO333/C3", 0),
  ("AO33/A1", 5),
  ("AO33/A2", 4),
  ("AO33/A3", 3),
  ("AO33/B1", 2),
  ("AO33/B2", 1),
  ("AO33/B3", 0),
  ("AOI211/A1", 3),
  ("AOI211/A2", 2),
  ("AOI211/B", 1),
  ("AOI211/C", 0),
  ("AOI21/A1", 2),
  ("AOI21/A2", 1),
  ("AOI21/B", 0),
  ("AOI221/A1", 4),
  ("AOI221/A2", 3),
  ("AOI221/B1", 2),
  ("AOI221/B2", 1),
  ("AOI221/C", 0),
  ("AOI222/A1", 5),
  ("AOI222/A2", 4),
  ("AOI222/B1", 3),
  ("AOI222/B2", 2),
  ("AOI222/C1", 1),
  ("AOI222/C2", 0),
  ("AOI22/A1", 3),
  ("AOI22/A2", 2),
  ("AOI22/B1", 1),
  ("AOI22/B2", 0),
  ("AOI311/A1", 4),
  ("AOI311/A2", 3),
  ("AOI311/A3", 2),
  ("AOI311/B", 1),
  ("AOI311/C", 0),
  ("AOI31/A1", 3),
  ("AOI31/A2", 2),
  ("AOI31/A3", 1),
  ("AOI31/B", 0), 
  ("AOI321/A1", 5),
  ("AOI321/A2", 4),
  ("AOI321/A3", 3),
  ("AOI321/B1", 2),
  ("AOI321/B2", 1),
  ("AOI321/C", 0),
  ("AOI322/A1", 6),
  ("AOI322/A2", 5),
  ("AOI322/A3", 4),
  ("AOI322/B1", 3),
  ("AOI322/B2", 2),
  ("AOI322/C1", 1),
  ("AOI322/C2", 0),
  ("AOI32/A1", 4),
  ("AOI32/A2", 3),
  ("AOI32/A3", 2),
  ("AOI32/B1", 1),
  ("AOI32/B2", 0),
  ("AOI331/A1", 6),
  ("AOI331/A2", 5),
  ("AOI331/A3", 4),
  ("AOI331/B1", 3),
  ("AOI331/B2", 2),
  ("AOI331/B3", 1),
  ("AOI331/C1", 0),
  ("AOI332/A1", 7),
  ("AOI332/A2", 6),
  ("AOI332/A3", 5),
  ("AOI332/B1", 4),
  ("AOI332/B2", 3),
  ("AOI332/B3", 2),
  ("AOI332/C1", 1),
  ("AOI332/C2", 0),
  ("AOI333/A1", 8),
  ("AOI333/A2", 7),
  ("AOI333/A3", 6),
  ("AOI333/B1", 5),
  ("AOI333/B2", 4),
  ("AOI333/B3", 3),
  ("AOI333/C1", 2),
  ("AOI333/C2", 1),
  ("AOI333/C3", 0),
  ("AOI33/A1", 5),
  ("AOI33/A2", 4),
  ("AOI33/A3", 3),
  ("AOI33/B1", 2),
  ("AOI33/B2", 1),
  ("AOI33/B3", 0),
  ("BUF/A", 0),
  ("CKINVDC/A", 0),
  ("HB1/A", 0),
  ("HB2/A", 0),
  ("HB3/A", 0),
  ("HB4/A", 0),
  ("INV/A", 0),
  ("O2A1O1I/A1", 3),
  ("O2A1O1I/A2", 2),
  ("O2A1O1I/B", 1),
  ("O2A1O1I/C", 0),
  ("OA211/A1", 3),
  ("OA211/A2", 2),
  ("OA211/B", 1),
  ("OA211/C", 0),
  ("OA21/A1", 2),
  ("OA21/A2", 1),
  ("OA21/B", 0),
  ("OA221/A1", 4),
  ("OA221/A2", 3),
  ("OA221/B1", 2),
  ("OA221/B2", 1),
  ("OA221/C", 0),
  ("OA222/A1", 5),
  ("OA222/A2", 4),
  ("OA222/B1", 3),
  ("OA222/B2", 2),
  ("OA222/C1", 1),
  ("OA222/C2", 0),
  ("OA22/A1", 3),
  ("OA22/A2", 2),
  ("OA22/B1", 1),
  ("OA22/B2", 0),
  ("OA31/A1", 3),
  ("OA31/A2", 2),
  ("OA31/A3", 1),
  ("OA31/B1", 0),
  ("OA331/A1", 6),
  ("OA331/A2", 5),
  ("OA331/A3", 4),
  ("OA331/B1", 3),
  ("OA331/B2", 2),
  ("OA331/B3", 1),
  ("OA331/C1", 0),
  ("OA332/A1", 7),
  ("OA332/A2", 6),
  ("OA332/A3", 5),
  ("OA332/B1", 4),
  ("OA332/B2", 3),
  ("OA332/B3", 2),
  ("OA332/C1", 1),
  ("OA332/C2", 0),
  ("OA333/A1", 8),
  ("OA333/A2", 7),
  ("OA333/A3", 6),
  ("OA333/B1", 5),
  ("OA333/B2", 4),
  ("OA333/B3", 3),
  ("OA333/C1", 2),
  ("OA333/C2", 1),
  ("OA333/C3", 0),
  ("OA33/A1", 5),
  ("OA33/A2", 4),
  ("OA33/A3", 3),
  ("OA33/B1", 2),
  ("OA33/B2", 1),
  ("OA33/B3", 0),
  ("OAI211/A1", 3),
  ("OAI211/A2", 2),
  ("OAI211/B", 1),
  ("OAI211/C", 0),
  ("OAI21/A1", 2),
  ("OAI21/A2", 1),
  ("OAI21/B", 0),
  ("OAI221/A1", 4),
  ("OAI221/A2", 3),
  ("OAI221/B1", 2),
  ("OAI221/B2", 1),
  ("OAI221/C", 0),
  ("OAI222/A1", 5),
  ("OAI222/A2", 4),
  ("OAI222/B1", 3),
  ("OAI222/B2", 2),
  ("OAI222/C1", 1),
  ("OAI222/C2", 0),
  ("OAI22/A1", 3),
  ("OAI22/A2", 2),
  ("OAI22/B1", 1),
  ("OAI22/B2", 0),
  ("OAI311/A1", 4),
  ("OAI311/A2", 3),
  ("OAI311/A3", 2),
  ("OAI311/B1", 1),
  ("OAI311/C1", 0),
  ("OAI31/A1", 3),
  ("OAI31/A2", 2),
  ("OAI31/A3", 1),
  ("OAI31/B", 0),
  ("OAI321/A1", 5),
  ("OAI321/A2", 4),
  ("OAI321/A3", 3),
  ("OAI321/B1", 2),
  ("OAI321/B2", 1),
  ("OAI321/C", 0),
  ("OAI322/A1", 6),
  ("OAI322/A2", 5),
  ("OAI322/A3", 4),
  ("OAI322/B1", 3),
  ("OAI322/B2", 2),
  ("OAI322/C1", 1),
  ("OAI322/C2", 0),
  ("OAI32/A1", 4),
  ("OAI32/A2", 3),
  ("OAI32/A3", 2),
  ("OAI32/B1", 1),
  ("OAI32/B2", 0),
  ("OAI331/A1", 6),
  ("OAI331/A2", 5),
  ("OAI331/A3", 4),
  ("OAI331/B1", 3),
  ("OAI331/B2", 2),
  ("OAI331/B3", 1),
  ("OAI331/C1", 0),
  ("OAI332/A1", 7),
  ("OAI332/A2", 6),
  ("OAI332/A3", 5),
  ("OAI332/B1", 4),
  ("OAI332/B2", 3),
  ("OAI332/B3", 2),
  ("OAI332/C1", 1),
  ("OAI332/C2", 0),
  ("OAI333/A1", 8),
  ("OAI333/A2", 7),
  ("OAI333/A3", 6),
  ("OAI333/B1", 5),
  ("OAI333/B2", 4),
  ("OAI333/B3", 3),
  ("OAI333/C1", 2),
  ("OAI333/C2", 1),
  ("OAI333/C3", 0),
  ("OAI33/A1", 5),
  ("OAI33/A2", 4),
  ("OAI33/A3", 3),
  ("OAI33/B1", 2),
  ("OAI33/B2", 1),
  ("OAI33/B3", 0),
  ("AND2/A", 1),
  ("AND2/B", 0),
  ("AND3/A", 2),
  ("AND3/B", 1),
  ("AND3/C", 0),
  ("AND4/A", 3),
  ("AND4/B", 2),
  ("AND4/C", 1),
  ("AND4/D", 0),
  ("AND5/A", 4),
  ("AND5/B", 3),
  ("AND5/C", 2),
  ("AND5/D", 1),
  ("AND5/E", 0),
  ("FA/A", 2),
  ("FA/B", 1),
  ("FA/CI", 0),
  ("HA/A", 1),
  ("HA/B", 0),
  ("MAJI/A", 2),
  ("MAJI/B", 1),
  ("MAJI/C", 0),
  ("MAJ/A", 2),
  ("MAJ/B", 1),
  ("MAJ/C", 0),
  ("NAND2/A", 1),
  ("NAND2/B", 0),
  ("NAND3/A", 2),
  ("NAND3/B", 1),
  ("NAND3/C", 0),
  ("NAND4/A", 3),
  ("NAND4/B", 2),
  ("NAND4/C", 1),
  ("NAND4/D", 0),
  ("NAND5/A", 4),
  ("NAND5/B", 3),
  ("NAND5/C", 2),
  ("NAND5/D", 1),
  ("NAND5/E", 0),
  ("NOR2/A", 1),
  ("NOR2/B", 0),
  ("NOR3/A", 2),
  ("NOR3/B", 1),
  ("NOR3/C", 0),
  ("NOR4/A", 3),
  ("NOR4/B", 2),
  ("NOR4/C", 1),
  ("NOR4/D", 0),
  ("NOR5/A", 4),
  ("NOR5/B", 3),
  ("NOR5/C", 2),
  ("NOR5/D", 1),
  ("NOR5/E", 0),
  ("OR2/A", 1),
  ("OR2/B", 0),
  ("OR3/A", 2),
  ("OR3/B", 1),
  ("OR3/C", 0),
  ("OR4/A", 3),
  ("OR4/B", 2),
  ("OR4/C", 1),
  ("OR4/D", 0),
  ("OR5/A", 4),
  ("OR5/B", 3),
  ("OR5/C", 2),
  ("OR5/D", 1),
  ("OR5/E", 0),
  ("XNOR2/A", 1),
  ("XNOR2/B", 0),
  ("XOR2/A", 1),
  ("XOR2/B", 0),
 ]);
}

pub struct MLCADDesignContest2025StdLib();

impl StandardCellTypeAttribute for MLCADDesignContest2025StdLib {
 fn get_celltype(
  &self,
  macro_name: &CompactString, pin_name: &CompactString, top_name: &CompactString,
  ) -> u16 {
   let celltype_name = 
    if (macro_name.split("x").collect::<Vec<_>>()[0] != CompactString::from("HA")) &&
    (macro_name.split("x").collect::<Vec<_>>()[0] != CompactString::from("FA")) { macro_name.split("x").collect::<Vec<_>>()[0] } 
    else { &(format!("{}{}", macro_name.split("x").collect::<Vec<_>>()[0], pin_name)) };
   match celltypeHash.get(&celltype_name) {
    Some(number) => *number,
    _ => match SEQ_REGEX.is_match(macro_name.as_str()) || macro_name == top_name {
     true => 999,
     _ => {use netlistdb::{HierName};
           panic!("Cannot recognize unknown celltype type {}, please make sure the verilog netlist is synthesized from Contest tech lib.",
           HierName::single(macro_name.clone()))
          }
    }
   }
  }

       // pin type attribute
 fn get_pintype(
  &self,
  macro_name: &CompactString,
  pin_name: &CompactString
  ) -> u8 {
   let celltype_name = macro_name.split("x").collect::<Vec<_>>()[0];
   let pintype_hashkey : &str = &(format!("{}/{}", celltype_name, *pin_name));
   match pintypeHash.get(pintype_hashkey) {
    Some(number) => *number,
    _ => {
           panic!("Cannot recognize unknown pin type {}, please make sure the verilog netlist is synthesized from Contest tech lib.",
           pintype_hashkey)
          }
   }
  }


}
