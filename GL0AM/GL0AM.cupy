/*##############################################################################
# Copyright (c) 2024, NVIDIA Corporation. All rights reserved.
#
# This work is made available under the Nvidia Source Code License-NC.
# To view a copy of this license, visit
# https://github.com/NVlabs/GL0AM/blob/main/LICENSE
#
##############################################################################*/

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateHowManyEndpointsDrivenPerNodeNonUniqueNonSorted( 
const int* howManyFanoutsPerNode, 
const int* loadBreakpointsPerNode,
const int* endpointsDrivenByEachLoad,
int* thisLevelHowManyEndpoints,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int numFanouts = howManyFanoutsPerNode[i]; int loadBreakpoint = loadBreakpointsPerNode[i];
int totalEndpoints = 0;
for (int j = 0 ; j < numFanouts ; j ++ ) {
  totalEndpoints += endpointsDrivenByEachLoad[loadBreakpoint + j] ;
}
thisLevelHowManyEndpoints[i] = totalEndpoints;
}  
}
'''
calculateHowManyEndpointsDrivenPerNodeNonUniqueNonSorted=cp.RawKernel(kernel_src_code, 'calculateHowManyEndpointsDrivenPerNodeNonUniqueNonSorted', backend='nvcc')
calculateHowManyEndpointsDrivenPerNodeNonUniqueNonSorted.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void storeTempEndpointsDrivenPerNode( 
const int* howManyFanoutsPerNode, 
const int* loadBreakpointsPerNode,
const int* endpointsDrivenByEachLoad,
const int* thisLevelHowManyEndpoints,
const int* listOfEndpointsStorage,
const int64_t* tempDrivenEndpointsPointerPerNode,
const int64_t* endpointsDrivenByEachLoadPointer,
int* tempEndpointsStorage,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int numFanouts = howManyFanoutsPerNode[i]; int loadBreakpoint = loadBreakpointsPerNode[i];
int64_t tempDrivenEndpointsPointerPerNodeTracker = tempDrivenEndpointsPointerPerNode[i];
//write the temp node numbers
for (int j = 0 ; j < numFanouts ; j ++ ) {
 int howManyEndpointsForThisLoad = endpointsDrivenByEachLoad[loadBreakpoint + j];
 int64_t thisLoadDrivenEndpointsPointer = endpointsDrivenByEachLoadPointer[loadBreakpoint + j];
 for (int k=0 ; k < howManyEndpointsForThisLoad ; k++ ) {
  int endpointNodeNum = listOfEndpointsStorage[thisLoadDrivenEndpointsPointer + int64_t(k)] ;
  tempEndpointsStorage[tempDrivenEndpointsPointerPerNodeTracker] = endpointNodeNum ; tempDrivenEndpointsPointerPerNodeTracker++;
 }
}
}
}
'''
storeTempEndpointsDrivenPerNode=cp.RawKernel(kernel_src_code, 'storeTempEndpointsDrivenPerNode', backend='nvcc')
storeTempEndpointsDrivenPerNode.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void storeEndpointsDrivenPerNodeFinal( 
const int* thisLevelHowManyEndpoints,
const int64_t* tempDrivenEndpointsPointerPerNode,
const int* tempEndpointsStorage,
const int* thisLevelHowManyEndpointsFinal,
const int64_t* drivenEndpointsPointerPerNodeFinal,
int* listOfEndpointsStorage,
int numNodes, int dummyNodeNum) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int previousNodeNumTracker =  dummyNodeNum; int readNodeNum;
int64_t beginRead = tempDrivenEndpointsPointerPerNode[i] ; int64_t endRead = beginRead + int64_t(thisLevelHowManyEndpoints[i]);
int64_t writePointer = drivenEndpointsPointerPerNodeFinal[i] ; 
for (int64_t j = beginRead; j < endRead ; j++ ) {
 readNodeNum = tempEndpointsStorage[j] ; 
 if (readNodeNum != previousNodeNumTracker) {
  listOfEndpointsStorage[writePointer] = readNodeNum ; previousNodeNumTracker = readNodeNum; writePointer++; 
 }
}
}
}
'''
storeEndpointsDrivenPerNodeFinal=cp.RawKernel(kernel_src_code, 'storeEndpointsDrivenPerNodeFinal', backend='nvcc')
storeEndpointsDrivenPerNodeFinal.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateDuplicates( 
const int* thisLevelHowManyEndpoints,
const int64_t* tempDrivenEndpointsPointerPerNode,
const int* tempEndpointsStorage,
int* numDuplicatesPerNode,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int64_t tempDrivenEndpointsPointerPerNodeTracker = tempDrivenEndpointsPointerPerNode[i]; ; int64_t right = tempDrivenEndpointsPointerPerNodeTracker + int64_t(thisLevelHowManyEndpoints[i])-1;
//now go through one more time and jot down the number of duplicates. Duplicates are defined as if current and next value are the same, then +1 duplicates
for (int64_t k = tempDrivenEndpointsPointerPerNodeTracker; k < right; k++) { 
 if (tempEndpointsStorage[k] == tempEndpointsStorage[k+1]) {
  numDuplicatesPerNode[i]++;
 }
}
}
}
'''
calculateDuplicates=cp.RawKernel(kernel_src_code, 'calculateDuplicates', backend='nvcc')
calculateDuplicates.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void segmentedCompare( 
const int* whichOffsetThisThreadBelongsTo,
const int64_t* sourcePointersRepeated,
const int64_t* dstPointersRepeated,
const int* listOfEndpointsStorage,
int8_t* perEndpointComparisonResults,
int64_t lastOffset) {
const int64_t i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < lastOffset) {
int64_t targetAddress = sourcePointersRepeated[i] + i - whichOffsetThisThreadBelongsTo[i] ;
int64_t targetAddress2 = dstPointersRepeated[i] + i - whichOffsetThisThreadBelongsTo[i] ;
perEndpointComparisonResults[i] = listOfEndpointsStorage[targetAddress] == listOfEndpointsStorage[targetAddress2] ? 1 : 0;
}
}
'''
segmentedCompare=cp.RawKernel(kernel_src_code, 'segmentedCompare', backend='nvcc')
segmentedCompare.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void segmentedCompareReduction( 
const int* perThreadStride,
const int* perThreadStrideOffsets,
const int* whichOffsetThisThreadBelongsTo,
int8_t* perEndpointComparisonResults,
int64_t totalThreads) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < totalThreads) {
int anchor = whichOffsetThisThreadBelongsTo[i] + i - perThreadStrideOffsets[i] ; 
perEndpointComparisonResults[anchor] = 
(perEndpointComparisonResults[anchor] == 1) && 
(perEndpointComparisonResults[anchor + perThreadStride[i]] == 1) ? 1 : 0;
}
}
'''
segmentedCompareReduction=cp.RawKernel(kernel_src_code, 'segmentedCompareReduction', backend='nvcc')
segmentedCompareReduction.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void assignMatchingClusterIDs( 
const int8_t* isThereMatchingCluster,
const int* inheritClusterIDs,
const int* howManyFanoutsPerNode,
const int* loadBreakpointsPerNode,
int* thisLevelClusterIDs,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int referenceBegin = loadBreakpointsPerNode[i];
for (int j = 0 ; j < howManyFanoutsPerNode[i] ; j++ ) {
 int compareAddress = j + referenceBegin; 
 if (isThereMatchingCluster[compareAddress] == 1) {
  thisLevelClusterIDs[i] = inheritClusterIDs[compareAddress];
  break;
 }
} 
}
}
'''
assignMatchingClusterIDs=cp.RawKernel(kernel_src_code, 'assignMatchingClusterIDs', backend='nvcc')
assignMatchingClusterIDs.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateEndpointsAndSumAttribute( 
const int64_t* level0EndpointListPointers,
const int* level0HowManyEndpoints,
const int* listOfEndpointsStorage,
int64_t* endpointIDSumsAndHowManyEndpoints,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int64_t pointerTracker = level0EndpointListPointers[i];
int64_t tempSum = 0;
for (int64_t j = 0 ; j < int64_t(level0HowManyEndpoints[i]) ; j++ ) {
 tempSum += int64_t(listOfEndpointsStorage[pointerTracker + j]);
}
tempSum = tempSum | (int64_t(level0HowManyEndpoints[i]) << 45);
endpointIDSumsAndHowManyEndpoints[i] = tempSum;
}
}
'''
calculateEndpointsAndSumAttribute=cp.RawKernel(kernel_src_code, 'calculateEndpointsAndSumAttribute', backend='nvcc')
calculateEndpointsAndSumAttribute.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateRanges( 
const int64_t* level0EndpointListPointers,
const int* level0HowManyEndpoints,
const int* listOfEndpointsStorage,
int64_t* endpointRanges,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int64_t tempRange = int64_t(listOfEndpointsStorage[level0EndpointListPointers[i]]);
int64_t end = int64_t(listOfEndpointsStorage[level0EndpointListPointers[i] + int64_t(level0HowManyEndpoints[i]) - 1]);
tempRange = tempRange | (end << 32);
endpointRanges[i] = tempRange;
}
}
'''
calculateRanges=cp.RawKernel(kernel_src_code, 'calculateRanges', backend='nvcc')
calculateRanges.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateVariances( 
const int64_t* level0EndpointListPointers,
const int* level0HowManyEndpoints,
const int* listOfEndpointsStorage,
const int64_t* endpointIDSumsAndHowManyEndpointsForVariance,
double* endpointVariances,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int64_t howManyEndpoints = (endpointIDSumsAndHowManyEndpointsForVariance[i] & 0xFFFFE00000000000) >> 45 ;
int64_t extractedSum = (endpointIDSumsAndHowManyEndpointsForVariance[i] & 0x00001FFFFFFFFFFF)  ;
double avg = double(extractedSum) / double(howManyEndpoints);
extractedSum = level0EndpointListPointers[i];
double covariance=0;
for (int64_t j = 0 ; j < howManyEndpoints ; j++ ) {
  float extractedNodeId = float(listOfEndpointsStorage[extractedSum + j]) ; 
  covariance += pow( (double(extractedNodeId) - avg), 2);
}
endpointVariances[i] = covariance/(double(howManyEndpoints-1)) ;
}
}
'''
calculateVariances=cp.RawKernel(kernel_src_code, 'calculateVariances', backend='nvcc')
calculateVariances.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateMedians( 
const int64_t* level0EndpointListPointers,
const int* level0HowManyEndpoints,
const int* listOfEndpointsStorage,
int64_t* endpointMedians,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int howManyEndpoints = level0HowManyEndpoints[i]; int64_t offset = int64_t(howManyEndpoints/2); 
if ((howManyEndpoints % 2) == 1) {
  endpointMedians[i] = int64_t(listOfEndpointsStorage[level0EndpointListPointers[i] + offset]);
} else {
  int64_t tempMedian = int64_t(listOfEndpointsStorage[level0EndpointListPointers[i] + offset]);
  tempMedian = tempMedian | (int64_t(listOfEndpointsStorage[level0EndpointListPointers[i] + offset - 1]) << 32) ;
  endpointMedians[i] = tempMedian;
}
}
}
'''
calculateMedians=cp.RawKernel(kernel_src_code, 'calculateMedians', backend='nvcc')
calculateMedians.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateSkewness( 
const int64_t* level0EndpointListPointers,
const int* level0HowManyEndpoints,
const int* listOfEndpointsStorage,
double* endpointSkews,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numNodes) {
int64_t howManyEndpoints = int64_t(level0HowManyEndpoints[i]);
double skewTemp=0;
for (int64_t j = 0 ; j < howManyEndpoints ; j++ ) {
  float extractedNodeId = float(listOfEndpointsStorage[level0EndpointListPointers[i] + j]) ; 
  skewTemp += pow(double(extractedNodeId), 3);
}
endpointSkews[i] = skewTemp/(double(howManyEndpoints-1)) ;
}
}
'''
calculateSkewness=cp.RawKernel(kernel_src_code, 'calculateSkewness', backend='nvcc')
calculateSkewness.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void fullComparisonAgainstMasterTensor( 
const int* masterCompareTensor,
const int64_t* comparisonPointers,
const int* listOfEndpointsStorage,
int8_t* fullComparisonResults,
int masterCompareNumEndpoints, int numCompareElements) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < numCompareElements) {
int64_t j = int64_t(i % masterCompareNumEndpoints) ; 
int64_t k = int64_t(i / masterCompareNumEndpoints) ;
fullComparisonResults[i] = (masterCompareTensor[j] == listOfEndpointsStorage[comparisonPointers[k] + j]) ? 1 : 0 ;
}
}
'''
fullComparisonAgainstMasterTensor=cp.RawKernel(kernel_src_code, 'fullComparisonAgainstMasterTensor', backend='nvcc')
fullComparisonAgainstMasterTensor.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void writeUniqueClusterIDAttributes(
const int* clusterIDs,
const int* howManyEndpoints,
const int64_t* endpointsStoragePointer,
int64_t* uniqueClusterIDPointers,
int* uniqueClusterIDHowManyEndpoints,
int numNodes) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < numNodes ) {
  int clusterID = clusterIDs[i];
  uniqueClusterIDHowManyEndpoints[clusterID] = howManyEndpoints[i];
  uniqueClusterIDPointers[clusterID] = endpointsStoragePointer[i];
}
}
'''
writeUniqueClusterIDAttributes=cp.RawKernel(kernel_src_code, 'writeUniqueClusterIDAttributes', backend='nvcc')
writeUniqueClusterIDAttributes.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void translateNodeIDToHypergraphNodeID(
const int* hypergraphVertexID,
const int* uniqueClusters1D,
int* scatterAddSlices,
int numValues) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < numValues ) {
  int nodeID = uniqueClusters1D[i];
  scatterAddSlices[i] = hypergraphVertexID[nodeID];
}
}
'''
translateNodeIDToHypergraphNodeID=cp.RawKernel(kernel_src_code, 'translateNodeIDToHypergraphNodeID', backend='nvcc')
translateNodeIDToHypergraphNodeID.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void storeUniqueClusters1D( 
const int* listOfEndpointsStorage,
const int64_t* uniqueClusterIDPointersRepeated,
const int* uniqueClusterIDHowManyEndpointsOffsetRepeated,
int* uniqueClusters1D,
int uniqueClusters1DSize) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < uniqueClusters1DSize) {
int64_t readAddress =  uniqueClusterIDPointersRepeated[i] + int64_t(i) - int64_t(uniqueClusterIDHowManyEndpointsOffsetRepeated[i]);
uniqueClusters1D[i] = listOfEndpointsStorage[readAddress];
}
}
'''
storeUniqueClusters1D=cp.RawKernel(kernel_src_code, 'storeUniqueClusters1D', backend='nvcc')
storeUniqueClusters1D.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void translateDGLNodesToHMetisNodes( 
const int* hypergraphVertexID,
const int* uniqueClusters1D,
int* uniqueClusters1DHMetisVersion,
int uniqueClusters1DSize) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;

if (i < uniqueClusters1DSize) {
uniqueClusters1DHMetisVersion[i] = hypergraphVertexID[uniqueClusters1D[i]];
}
}
'''
translateDGLNodesToHMetisNodes=cp.RawKernel(kernel_src_code, 'translateDGLNodesToHMetisNodes', backend='nvcc')
translateDGLNodesToHMetisNodes.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void updateClockTreeSaif( 
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
const int* listOfClkTreeComponents,
uint64_t* T0s,
uint32_t* TCs,
const uint32_t* pushoutDelaysRise,
const uint32_t* pushoutDelaysFall,
const int num_splits, const int num_nodes, const uint64_t fold_split, const uint64_t subchunkStart, const uint64_t subchunkEnd, const uint64_t firstEdge, const uint64_t period  ) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < num_nodes  ) {
 uint64_t extracted_value, extracted_time, current_time, current_value, endOfSplit, initOffset; uint32_t vc;
 uint64_t halfCycle = uint64_t(0.5*period) ;
 uint64_t T1_master, T1_middle, TC; int nodeNum = listOfClkTreeComponents[i];
 T1_master = 0 ; T1_middle = 0 ; TC = 0;
 for (int k=0 ; k < num_splits; k++) {
  int64_t thisGATSPIPointerCurrent = perNodePerSplitWaveformPointerStart[i*num_splits+k];
  int64_t thisGATSPIPointerEnd = perNodePerSplitWaveformPointerEnd[i*num_splits+k];
  uint64_t timeOffset = uint64_t(uint64_t(fold_split) * uint64_t(k)) + subchunkStart;
  endOfSplit = (k==31) ? subchunkEnd : timeOffset + uint64_t(fold_split);
  vc = new_waveforms_total[ thisGATSPIPointerCurrent ] ;
  current_value  = uint64_t((vc & 0xC0000000) >> 30); current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  extracted_value = current_value ; extracted_time = current_time;
  thisGATSPIPointerCurrent++;
  if ( (k==0) && (timeOffset==0) && (current_value == 1) ) { current_time = firstEdge; }
  else if ( (k==0) && (current_value == 1) ) {
   initOffset = ((current_time - firstEdge) % period) ; 
   if (initOffset <= halfCycle) {
    T1_master += halfCycle - initOffset + uint64_t(pushoutDelaysFall[i]) - uint64_t(pushoutDelaysRise[i]) ; TC += 1;
   }
   current_time += period - initOffset ;
  }
  for (int64_t j = thisGATSPIPointerCurrent ; j < (thisGATSPIPointerEnd-1) ; j++ ) {
   vc = new_waveforms_total[ j ] ;
   extracted_value  = uint64_t((vc & 0xC0000000) >> 30); extracted_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
   if ( extracted_value != 1 && current_value == 1) {
    T1_middle += extracted_time - current_time ; 
   }
   current_value  = extracted_value; current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  }
  //Add the last switch to fold_split T0, T1, TX values.
  if ( current_value == 1 ) {
   if ( k != 31 ) { T1_middle +=  endOfSplit - current_time ; }
   else { 
    initOffset = ((subchunkEnd - firstEdge) % period) ;
	T1_master += min(initOffset, halfCycle);
    if (initOffset > halfCycle) {
     TC += 1; T1_master = T1_master + uint64_t(pushoutDelaysFall[i]) - uint64_t(pushoutDelaysRise[i]) ;
    }
    T1_middle += subchunkEnd - initOffset - current_time ;
   }
  }
 }
 TC += uint64_t(T1_middle/period) * 2 ; TCs[nodeNum] = uint32_t(TC);
 T1_master += uint64_t(T1_middle * 0.5) + (uint64_t(T1_middle/period) * uint64_t(pushoutDelaysFall[i]))  - (uint64_t(T1_middle/period) * uint64_t(pushoutDelaysRise[i])) ; 
 T0s[nodeNum] = subchunkEnd -subchunkStart - T1_master;
}
}
'''
updateClockTreeSaif=cp.RawKernel(kernel_src_code, 'updateClockTreeSaif', backend='nvcc')
updateClockTreeSaif.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <math.h>
extern "C" __global__ void simulate_seq_stage3d_4val( 
const int8_t* previous_states,
int8_t* current_logic_value,
uint64_t* output_waveforms_storage,
const int* first_level_inputs_seq_list,
const int* cell_types_seq_list,
const int* seq_nodes_list,
const int* node_breakpoints_seq_start,
const int8_t* seq_logics,
const int64_t* temp_active_timestamps,
uint32_t* global_vc_write_pointer,
const uint32_t* pushout_delays,
uint32_t* numOfSwitchesPerDriverPerSplit,
const int stage, const int cycle, const int nodes_size, const int num_splits, const uint64_t fold_split) {
  const int i = blockIdx.x * blockDim.x + threadIdx.x ;
  if ( i < nodes_size ) {
    int node_ref_begin = (node_breakpoints_seq_start[stage]+i); int node_num = seq_nodes_list[node_ref_begin];
 // start simulation here // assign all input pin values.
   int8_t SDN = 1 ; int8_t CDN = 1 ; int8_t  CP = 1 ; int8_t SE = 0 ; int8_t SI = 0 ; int8_t D = 0 ; int8_t ENABLE = 1 ; 
   if ( ( cell_types_seq_list[node_ref_begin] < 300 ) && (cell_types_seq_list[node_ref_begin] >= 200) ) { //it's a flop we are  simulating
     //change all the input pin values that have connections
     //then, execute the simulation logic evaluation
     //make changes to i/o values based on the cell type 'footprint' of the cell
           D = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] ; 
           SI = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+1 ]] ; 
           SE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+2 ]] ; 
           ENABLE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+3 ]] ; 
           SDN = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+4 ]] ; 
           CDN = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+5 ]] ; 
           CP = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+6 ]] ; 
           int8_t effD = ENABLE == 1 ? D : ENABLE == 0 ? previous_states[node_ref_begin] : 2; effD = SE == 1 ? SI : SE == 0 ? effD : 2;
     if (cell_types_seq_list[node_ref_begin] & 1) {
       CP= (CP == 2) ? 2 :
           (CP == 1) ? 0 : 1;
     }
     //current_logic_value[seq_nodes_list[node_ref_begin]] = ( ~SDN | ( ( CP & ( (SI & SE) | (~SE & D & ENABLE) | (~SE & ~ENABLE & previous_states[node_ref_begin]) ) ) | (~CP & previous_states[node_ref_begin]) ) ) & CDN ;
     current_logic_value[node_num] = (CDN==0) ? 0 : 
                                     (SDN==0 && CDN==1) ? 1 :
                                     (SDN==2 && CDN==1) ? 2 :
                                     ((effD==2) && (previous_states[node_ref_begin]==1)) ? 1 :
                                     (effD==2) ? 0 : 
                                     ((previous_states[node_ref_begin]==2) && (CP != 1)) ? 0 :
                                     seq_logics[int(CP)+int(previous_states[node_ref_begin])*3 + int(SI)*9+int(SE)*27+int(ENABLE)*81+int(D)*243+int(SDN)*729+int(CDN)*2187] ;
	 if (cell_types_seq_list[node_ref_begin] & 2) {
       current_logic_value[node_num] = (current_logic_value[node_num]==2) ? 2:
                                       (current_logic_value[node_num]==1) ? 0 : 1;
     }
    } else if ( ( cell_types_seq_list[node_ref_begin] < 400 ) && (cell_types_seq_list[node_ref_begin] >= 200) ) { //it's a clk gate we are  simulating
     int8_t TD = 0 ; int8_t TE = 0;
           D = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] ; 
           SI = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+1 ]];
           SE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+2 ]] ;   
           TD = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+5 ]] ; 
           SDN = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+4 ]] ; 																						  
           TE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+7 ]] ; 																						 
           CP = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+6 ]] ; 
     
     if (cell_types_seq_list[node_ref_begin] & 1) {
       CP= (CP == 2) ? 2 :
           (CP == 1) ? 0 : 1;
     }
     //current_logic_value[seq_nodes_list[node_ref_begin]] = ~SDN | ( ( ( ( ~TD & ( (SI & SE) | (~SE & D) ) ) | TE ) & CP ) | (~CP & previous_states[node_ref_begin]) ) ;
	 current_logic_value[node_num] = SDN==0 ? 1 :
	                                 SDN==1 && CDN==0 ? 0 :
									 seq_logics[6561+int(CP)+int(previous_states[node_ref_begin])*3+int(TE)*9+int(TD)*27+int(SI)*81+int(SE)*243+int(D)*729+int(SDN)*2187] ;
     if (cell_types_seq_list[node_ref_begin] & 2) {
       current_logic_value[node_num] = (current_logic_value[node_num]==2) ? 2:
                                       (current_logic_value[node_num]==1) ? 0 : 1;
     }
    } else if ( ( cell_types_seq_list[node_ref_begin] >= 400 ) && (cell_types_seq_list[node_ref_begin] < 500) ) { //it's a latch, different rules
     int8_t TD = 0 ; int8_t TE = 0;
           D = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] ; 
           SI = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+1 ]];
           SE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+2 ]] ;   
           TD = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+5 ]] ; 
           SDN = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+4 ]] ; 
           TE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+7 ]] ; 
           CP = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+6 ]] ; 
     if (cell_types_seq_list[node_ref_begin] & 1) {
       CP= (CP == 2) ? 2 :
           (CP == 1) ? 0 : 1;
     }
     //current_logic_value[seq_nodes_list[node_ref_begin]] = ~SDN | ( ( ( ( ~TD & ( (SI & SE) | (~SE & D) ) ) | TE ) & CP ) | (~CP & previous_states[node_ref_begin]) ) ;
	 current_logic_value[node_num] = SDN==0 ? 1 :
	                                 SDN==1 && CDN==0 ? 0 :
								     seq_logics[13122+int(CP)+int(previous_states[node_ref_begin])*3+int(TE)*9+int(TD)*27+int(SI)*81+int(SE)*243+int(D)*729+int(SDN)*2187] ;
      if (cell_types_seq_list[node_ref_begin] & 2) {
       current_logic_value[node_num] = (current_logic_value[node_num]==2) ? 2:
                                       (current_logic_value[node_num]==1) ? 0 : 1;
     }
    } else if (cell_types_seq_list[node_ref_begin] == 21 ) { current_logic_value[node_num] = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] ; } 
	else if (  cell_types_seq_list[node_ref_begin] == 24 ) { current_logic_value[node_num] = (current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] == 2) ? 2 : (current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] == 0) ? 1 : 0 ; } 
    //finally, write results to output_waveforms_storage
	if (previous_states[node_ref_begin] != current_logic_value[node_num]) {	  
	  uint64_t vc_point =uint64_t(temp_active_timestamps[cycle]);
	  uint64_t pushout_delay = current_logic_value[node_num]==0 ? uint64_t(pushout_delays[node_ref_begin] & 0x0000FFFF) :
	                           current_logic_value[node_num]==1 ? uint64_t((pushout_delays[node_ref_begin] & 0xFFFF0000) >> 16) :
							   previous_states[node_ref_begin]==0 ? uint64_t((pushout_delays[node_ref_begin] & 0xFFFF0000) >> 16) : uint64_t(pushout_delays[node_ref_begin] & 0x0000FFFF) ;
      vc_point += pushout_delay; int split = int(vc_point / fold_split);  numOfSwitchesPerDriverPerSplit[node_ref_begin*num_splits + split]++ ; 
	  vc_point = vc_point | (uint64_t(current_logic_value[node_num]) << 62) ;
	  vc_point = vc_point | (uint64_t(node_num) << 32) ; 
	  uint32_t vc_point_write_address = atomicAdd(&global_vc_write_pointer[0],1);
	  output_waveforms_storage[vc_point_write_address] = vc_point;
	}

  }
}
'''
simulate_seq_stage3d_4val=cp.RawKernel(kernel_src_code, 'simulate_seq_stage3d_4val',backend='nvcc')
simulate_seq_stage3d_4val.compile() ;





kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__
void simulateClkTreeBuffs( 
int8_t* current_logic_value, 
const int* clkTreeNodesList,
const int* clkTreeDriversList,
const int* node_breakpoints_start,
const int* combo_celltypes_list,
const int numBuffers, const int stage) {
const int i = blockDim.x * blockIdx.x + threadIdx.x;  
if ( i < numBuffers ) {
  int node_ref_begin = (node_breakpoints_start[stage]+i); int nodeNum = clkTreeNodesList[node_ref_begin]; int nodeDriver = clkTreeDriversList[node_ref_begin] ;
  int cellType = combo_celltypes_list[node_ref_begin] ; 
  if ( cellType == 21 ) { current_logic_value[nodeNum] = current_logic_value[nodeDriver] ; } 
  else if (  cellType == 24 ) { current_logic_value[nodeNum] = (current_logic_value[nodeDriver] == 2) ? 2 : (current_logic_value[nodeDriver] == 0) ? 1 : 0 ; }  
}
}
'''
simulateClkTreeBuffs=cp.RawKernel(kernel_src_code, 'simulateClkTreeBuffs',backend='nvcc')
simulateClkTreeBuffs.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void formatWholeInputWaveformsForGATSPISubchunking( 
const int64_t* waveforms_total,
const int8_t* waveforms_values_total,
uint64_t* saveInputWaveformsTotal,
const uint64_t numVCs, const uint64_t end_token ) {
const uint64_t i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < numVCs  ) {
 uint64_t VCtemp = uint64_t(waveforms_total[i]);
 if (VCtemp == end_token) {
  saveInputWaveformsTotal[i] = end_token ; 
 } else {
  saveInputWaveformsTotal[i] = VCtemp | (uint64_t(waveforms_values_total[i]) << 62) ;
 }
}
}
'''
formatWholeInputWaveformsForGATSPISubchunking=cp.RawKernel(kernel_src_code, 'formatWholeInputWaveformsForGATSPISubchunking', backend='nvcc')
formatWholeInputWaveformsForGATSPISubchunking.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void setFullWaveformRegisterPseudoInputsBlockProcess( 
const uint64_t* output_waveforms_storage,
const uint32_t* foldSplitBeginIndexes,
uint32_t* perDriverPerSplitPointersBegin_tracker,
uint64_t* saveRegisterWaveformsTotal,
const int* index_T,
const int num_splits) {
const int i = blockIdx.x ;
uint64_t extracted_value, write_address, extracted_driver, extracted_timestamp ; int extracted_index ; 
uint32_t thisOutputWaveformIndex = foldSplitBeginIndexes[i]; uint32_t theOutputWaveformEndIndex = foldSplitBeginIndexes[i+1];
//write_address = perDriverPerSplitPointersBegin[i*num_splits + j] + 1;
while (thisOutputWaveformIndex < theOutputWaveformEndIndex ) {
  extracted_driver = uint64_t((output_waveforms_storage[thisOutputWaveformIndex] & 0x3FFFFFFF00000000) >> 32);
  extracted_index = index_T[extracted_driver] ;
  extracted_value = uint64_t((output_waveforms_storage[thisOutputWaveformIndex] & 0xC000000000000000));
  extracted_timestamp = uint64_t((output_waveforms_storage[thisOutputWaveformIndex] & 0x00000000FFFFFFFF));
  extracted_timestamp  = extracted_timestamp | extracted_value;
  write_address = perDriverPerSplitPointersBegin_tracker[extracted_index*num_splits + i]; perDriverPerSplitPointersBegin_tracker[extracted_index*num_splits + i]++;
  saveRegisterWaveformsTotal[write_address]  = extracted_timestamp ;
  thisOutputWaveformIndex++;
}
}
'''
setFullWaveformRegisterPseudoInputsBlockProcess=cp.RawKernel(kernel_src_code, 'setFullWaveformRegisterPseudoInputsBlockProcess', backend='nvcc')
setFullWaveformRegisterPseudoInputsBlockProcess.compile() ;






kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void getSignalStateAtTimestamp( 
uint64_t* wholeWaveformTempStorage,
const uint32_t wholeWaveformPointerOffset,
uint8_t* vcValue,
uint64_t targetTimestamp, uint32_t totalTimestampsInWaveform ) {
const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < totalTimestampsInWaveform  ) {
 uint32_t targetVc = i + wholeWaveformPointerOffset; 
 uint64_t vc = wholeWaveformTempStorage[targetVc]; uint64_t extracted_time = (vc & 0x3FFFFFFFFFFFFFFF) ; 
 if (i != (totalTimestampsInWaveform -1)) {
  uint64_t nextVc = wholeWaveformTempStorage[targetVc+1]; uint64_t extractedNextTime = (nextVc & 0x3FFFFFFFFFFFFFFF) ; 
  if ( (extracted_time <= targetTimestamp) && (extractedNextTime > targetTimestamp) ) { vcValue[0] = uint8_t((vc & 0xC000000000000000) >> 62) ; }
 } else if ( extracted_time <= targetTimestamp ) { vcValue[0] = uint8_t((vc & 0xC000000000000000) >> 62) ; } 
}
}
'''
getSignalStateAtTimestamp=cp.RawKernel(kernel_src_code, 'getSignalStateAtTimestamp', backend='nvcc')
getSignalStateAtTimestamp.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void getVCDIndexesOfSignalInTimerange( 
uint64_t* wholeWaveformTempStorage,
uint32_t* indexValues,
uint64_t timeStart, uint64_t timeEnd, uint32_t totalTimestampsInWaveform ) {
const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < totalTimestampsInWaveform  ) {
 uint64_t vc = wholeWaveformTempStorage[i]; uint64_t extracted_time = (vc & 0x3FFFFFFFFFFFFFFF) ; 
 if (i != (totalTimestampsInWaveform -1)) {
  uint64_t nextVc = wholeWaveformTempStorage[i+1]; uint64_t extractedNextTime = (nextVc & 0x3FFFFFFFFFFFFFFF) ; 
  if ( (extracted_time <= timeStart) && (extractedNextTime > timeStart) ) { indexValues[0] = i ; }
  if ( (extracted_time <= timeEnd) && (extractedNextTime > timeEnd) ) { indexValues[1] = i ; }
 } else {
  if ( extracted_time <= timeStart ) { indexValues[0] = i ; }
  if ( extracted_time <= timeEnd ) { indexValues[1] = i ; }  
 }
}
}
'''
getVCDIndexesOfSignalInTimerange=cp.RawKernel(kernel_src_code, 'getVCDIndexesOfSignalInTimerange', backend='nvcc')
getVCDIndexesOfSignalInTimerange.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void extractTimeAndValue( 
uint64_t* wholeWaveformTempStorage,
uint32_t* indexValues,
uint8_t* Values,
uint64_t* Timestamps,
uint32_t totalTimestampsInSubWaveform ) {
const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < totalTimestampsInSubWaveform  ) {
 uint64_t vc = wholeWaveformTempStorage[i + indexValues[0]]; uint64_t extracted_time = (vc & 0x3FFFFFFFFFFFFFFF) ; 
 uint8_t extracted_value = uint8_t((vc & 0xC000000000000000) >> 62) ;
 Values[i] = extracted_value; Timestamps[i] = extracted_time;
}
}
'''
extractTimeAndValue=cp.RawKernel(kernel_src_code, 'extractTimeAndValue', backend='nvcc')
extractTimeAndValue.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void setFoldedRegisterPseudoInputsBlockProcess( 
const uint64_t* output_waveforms_storage,
const uint32_t* foldSplitBeginIndexes,
uint32_t* perDriverPerSplitPointersBegin_tracker,
uint32_t* waveforms_total,
const int* index_T,
const int num_splits, const uint32_t fold_split) {
const int i = blockIdx.x ;
uint32_t extracted_value, write_address, extracted_driver, extracted_timestamp ; int extracted_index ;
//uint32_t this_driver = uint32_t(nodes_list_gpu_seqs[i]); 
uint32_t thisOutputWaveformIndex = foldSplitBeginIndexes[i]; uint32_t theOutputWaveformEndIndex = foldSplitBeginIndexes[i+1];
//write_address = perDriverPerSplitPointersBegin[i*num_splits + j] + 1;
while (thisOutputWaveformIndex < theOutputWaveformEndIndex ) {
  extracted_driver = uint32_t((output_waveforms_storage[thisOutputWaveformIndex] & 0x3FFFFFFF00000000) >> 32);
  extracted_index = index_T[extracted_driver] ;
  extracted_value = uint32_t((output_waveforms_storage[thisOutputWaveformIndex] & 0xC000000000000000) >> 32);
  extracted_timestamp = uint32_t((output_waveforms_storage[thisOutputWaveformIndex] & 0x00000000FFFFFFFF));
  extracted_timestamp -= (uint32_t)i * fold_split; extracted_timestamp  = extracted_timestamp | extracted_value;
  write_address = ++perDriverPerSplitPointersBegin_tracker[extracted_index*num_splits + i];
  waveforms_total[write_address]  = extracted_timestamp ;
  thisOutputWaveformIndex++;
}
}
'''
setFoldedRegisterPseudoInputsBlockProcess=cp.RawKernel(kernel_src_code, 'setFoldedRegisterPseudoInputsBlockProcess', backend='nvcc')
setFoldedRegisterPseudoInputsBlockProcess.compile() ;


kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void setFoldedRegisterWaveformsInitAndEndTokenValues( 
const uint32_t* perDriverPerSplitPointersBegin,
const uint32_t* perDriverPerSplitPointersEnd,
uint32_t* waveforms_total,
const int num_splits, const int num_of_drivers, const uint32_t end_token) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
const int j = threadIdx.y;
uint32_t write_address, extracted_value;
if ( i < num_of_drivers ) {
  if ( j ==0 ) { 
    write_address = perDriverPerSplitPointersBegin[i*num_splits]; 
	waveforms_total[write_address] = 2147483648; //should be 0?
  } else {
    int k = j;
    while ( (k > 1) && ((perDriverPerSplitPointersBegin[i*num_splits + k] -2) == perDriverPerSplitPointersBegin[i*num_splits + k-1]) ) {
      k--;
    }
    write_address = perDriverPerSplitPointersBegin[i*num_splits + k] -2 ; 
	extracted_value  = (waveforms_total[write_address] & 0xC0000000);
	write_address = perDriverPerSplitPointersBegin[i*num_splits + j]; waveforms_total[write_address] = extracted_value;
  }
  write_address = perDriverPerSplitPointersEnd[i*num_splits + j]-1;
  waveforms_total[write_address] = end_token;
}
}
'''
setFoldedRegisterWaveformsInitAndEndTokenValues=cp.RawKernel(kernel_src_code, 'setFoldedRegisterWaveformsInitAndEndTokenValues', backend='nvcc')
setFoldedRegisterWaveformsInitAndEndTokenValues.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void setIndex_T(
const int* nodes_list_gpu_seqs,
int* index_T,
const int num_of_drivers) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < num_of_drivers ) {
  index_T[nodes_list_gpu_seqs[i]] = i;
}
}
'''
setIndex_T=cp.RawKernel(kernel_src_code, 'setIndex_T', backend='nvcc')
setIndex_T.compile() ;




kernel_src_code = r'''
#include <stdint.h>
#include <vector>
#include <math.h>
#include <float.h>
#include <algorithm>
#include <cstdlib>
extern "C" __global__ void writeInputWaveforms( 
const int64_t* waveforms_total,
const int8_t* waveforms_values_total,
const int64_t* pointers_temp,
int64_t* perInputPerSplitPointersBegin_tracker,
const int64_t* perInputPerSplitPointersBegin,
uint32_t* inputWaveformsStorage,
int64_t fold_split, int64_t num_splits, int64_t nodes_size, int64_t sim_duration) {
const int64_t i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < nodes_size  ) {
  int64_t end_index = pointers_temp[i+1]-1; int64_t j= pointers_temp[i]; int64_t write_address; uint32_t extracted_value;
  while ( (j < end_index) && (waveforms_total[j] <= sim_duration) ) {
    int64_t split = int64_t(waveforms_total[j] / fold_split);  perInputPerSplitPointersBegin_tracker[i*num_splits + split]++ ; 
	write_address = perInputPerSplitPointersBegin_tracker[i*num_splits + split];
	uint32_t extracted_timestamp = uint32_t(waveforms_total[j] - fold_split * split) ; 
	extracted_value = uint32_t(waveforms_values_total[j]) << 30;
	extracted_timestamp = extracted_timestamp | extracted_value;
	inputWaveformsStorage[write_address] = extracted_timestamp;
	j++;
  }
  for (int64_t k = 0 ; k < num_splits ; k++ ) {
    if (k==0) { write_address = perInputPerSplitPointersBegin[i*num_splits]; inputWaveformsStorage[write_address]  = 2147483648; }
	else { write_address = perInputPerSplitPointersBegin[i*num_splits + k] -2 ; extracted_value = inputWaveformsStorage[write_address] & 0xC0000000 ; 
	  write_address += 2; inputWaveformsStorage[write_address] = extracted_value;
	}
  }	
}
}
'''
writeInputWaveforms=cp.RawKernel(kernel_src_code, 'writeInputWaveforms', backend='nvcc')
writeInputWaveforms.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <vector>
#include <math.h>
#include <float.h>
#include <algorithm>
#include <cstdlib>
#include <cmath>
extern "C" __global__ void calculateNumberOfPerSplitSwitches( 
const uint64_t* saveRegisterWaveformsTotal,
const int64_t* saveRegisterPointers,
int64_t* saveRegisterPointers_tracker,
uint8_t* initValuesOfSubchunk,
uint32_t* numOfPerDriverPerSplitSwitches,
int64_t* thisSubchunkStartPointer,
uint32_t fold_split, uint32_t num_splits, uint32_t nodes_size, uint64_t subchunkStart, uint64_t subchunkEnd) {
const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < nodes_size  ) {
 uint64_t extractedValue, extractedTimestamp, vc; uint32_t split; int64_t initialSaveRegisterPointers_tracker = saveRegisterPointers_tracker[i];
 if ( saveRegisterPointers_tracker[i] == (saveRegisterPointers[i+1]-1) ) {
  extractedValue = ((saveRegisterWaveformsTotal[ saveRegisterPointers_tracker[i] - 1 ] & 0xC000000000000000) >> 62) ;
  initValuesOfSubchunk[i] = uint8_t(extractedValue);
  thisSubchunkStartPointer[i] =  saveRegisterPointers_tracker[i];
 }
 while ( saveRegisterPointers_tracker[i] < (saveRegisterPointers[i+1]-1) ) {
  vc = saveRegisterWaveformsTotal[ saveRegisterPointers_tracker[i] ];
  extractedTimestamp = (vc & 0x3FFFFFFFFFFFFFFF) ;
  if ( (extractedTimestamp < subchunkStart) && ( (saveRegisterWaveformsTotal[ saveRegisterPointers_tracker[i] + 1 ] & 0x3FFFFFFFFFFFFFFF) > subchunkStart ) ) {
   extractedValue = ((vc & 0xC000000000000000) >> 62) ;  initValuesOfSubchunk[i] = uint8_t(extractedValue);
   thisSubchunkStartPointer[i] =  saveRegisterPointers_tracker[i] + 1;
  } else if ( extractedTimestamp == subchunkStart ) {
   if ( subchunkStart == 0 ) {
    extractedValue = ((vc & 0xC000000000000000) >> 62) ;  initValuesOfSubchunk[i] = uint8_t(extractedValue);
	thisSubchunkStartPointer[i] =  saveRegisterPointers_tracker[i] + 1;
   } else {
    extractedValue = ((saveRegisterWaveformsTotal[ saveRegisterPointers_tracker[i] - 1 ] & 0xC000000000000000) >> 62) ;  initValuesOfSubchunk[i] = uint8_t(extractedValue);
	thisSubchunkStartPointer[i] =  saveRegisterPointers_tracker[i];
	numOfPerDriverPerSplitSwitches[i*num_splits]++;
   }
  } else if ( (extractedTimestamp > subchunkStart) && (extractedTimestamp < subchunkEnd) ) {
   split = uint32_t(uint32_t(extractedTimestamp - subchunkStart) / fold_split); numOfPerDriverPerSplitSwitches[i*num_splits + split]++;
   if ( (saveRegisterPointers_tracker[i] != saveRegisterPointers[i]) && ( (saveRegisterWaveformsTotal[ saveRegisterPointers_tracker[i] - 1 ] & 0x3FFFFFFFFFFFFFFF) < subchunkStart ) ) {
    extractedValue = ((saveRegisterWaveformsTotal[ saveRegisterPointers_tracker[i] - 1 ] & 0xC000000000000000) >> 62) ;  initValuesOfSubchunk[i] = uint8_t(extractedValue);
	thisSubchunkStartPointer[i] =  saveRegisterPointers_tracker[i];
   }
  } else if ( extractedTimestamp >= subchunkEnd ) {
   if ( saveRegisterPointers_tracker[i] == initialSaveRegisterPointers_tracker ) { //there are no switches in this subchunk
    extractedValue = ((saveRegisterWaveformsTotal[ saveRegisterPointers_tracker[i] - 1 ] & 0xC000000000000000) >> 62) ;
    initValuesOfSubchunk[i] = uint8_t(extractedValue);
    thisSubchunkStartPointer[i] =  saveRegisterPointers_tracker[i];
   }
   break;
  } 
  saveRegisterPointers_tracker[i]++;
 }
}
}
'''
calculateNumberOfPerSplitSwitches=cp.RawKernel(kernel_src_code, 'calculateNumberOfPerSplitSwitches', backend='nvcc')
calculateNumberOfPerSplitSwitches.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <vector>
#include <math.h>
#include <float.h>
#include <algorithm>
#include <cstdlib>
extern "C" __global__ void writeDriverWaveforms( 
const uint64_t* saveRegisterWaveformsTotal,
const int64_t* thisSubchunkStartPointer,
const int64_t* saveRegisterPointers_tracker,
const uint64_t* perDriverPerSplitPointersBegin,
uint64_t* perDriverPerSplitPointersBegin_tracker,
const uint8_t* initValuesOfSubchunk,
uint32_t* driverWaveformsStorage,
uint32_t fold_split, uint32_t num_splits, uint32_t nodes_size, uint64_t subchunkStart, uint64_t subchunkEnd) {
const uint32_t i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < nodes_size  ) {
  uint64_t end_index = saveRegisterPointers_tracker[i]; uint64_t j= thisSubchunkStartPointer[i]; uint64_t vc, write_address, extracted_value, extracted_timestamp; uint32_t split, writeValue;
  while ( j < end_index ) {
    vc = saveRegisterWaveformsTotal[ j ] ; extracted_timestamp = (vc & 0x3FFFFFFFFFFFFFFF) ; extracted_value = ((vc & 0xC000000000000000) >> 62) ;
    split = uint32_t(uint32_t(extracted_timestamp - subchunkStart) / fold_split); perDriverPerSplitPointersBegin_tracker[i*num_splits + split]++;
	write_address = perDriverPerSplitPointersBegin_tracker[i*num_splits + split];
	writeValue = uint32_t(extracted_timestamp - subchunkStart) - fold_split * split ; 
	writeValue = writeValue | (uint32_t(extracted_value) << 30);
	driverWaveformsStorage[write_address] = writeValue;
	j++;
  }
  for (uint32_t k = 0 ; k < num_splits ; k++ ) {
    if (k==0) { 
	  write_address = perDriverPerSplitPointersBegin[i*num_splits]; 
	  driverWaveformsStorage[write_address]  = (uint32_t(initValuesOfSubchunk[i]) << 30); 
	} else { 
	  write_address = perDriverPerSplitPointersBegin[i*num_splits + k] -2 ; uint32_t extracted_value2 = driverWaveformsStorage[write_address] & 0xC0000000 ; 
	  write_address += 2; driverWaveformsStorage[write_address] = extracted_value2;
	}
  }	
}
}
'''
writeDriverWaveforms=cp.RawKernel(kernel_src_code, 'writeDriverWaveforms', backend='nvcc')
writeDriverWaveforms.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <cooperative_groups.h>
extern "C" __global__
void simulate_rams( 
int8_t* current_logic_value, //to read and write values of node nums
bool* M_01, //store all the ram contents in memory. 2 bits to store each mem bit
bool* M_XZ,
//bool* ram_output_waveforms_storage_01,
//bool* ram_output_waveforms_storage_XZ, //same thing for per cycle/event waveform storage, 2 bits to store each result
int* ra_d, // previous states, per thread
const int* ram_id, //the ram_id assigned per thread
const int* clk_ra_re_ore_wa_we_bypsel_address, //all the node_nums for each ram_id. from left to right is: 
//1 clk + 12 ra + 1 re + 1 ore + 12 wa + 1 we + 1 bypsel = 29 addresses per ram
const int* di_address, // each bit's read address, length should match total number of bits in all rams
const int* dout_address,
const int* dbyp_address,  //same, but follows ram_byp_widths
const int* M_breakpoints,
const int* ram_thread_breakpoints,
const int* ram_col_widths, //tools to figure out which ram column the thread i is working on
const int64_t* temp_active_timestamps,
uint32_t* global_vc_write_pointer,
uint32_t* numOfSwitchesPerDriverPerSplitRAMs,
uint64_t* output_waveforms_storage,
const int cycle, const int address_space_width, const int ra_x_address, const int total_bits, const int num_splits, const uint64_t fold_split) {
int i = blockIdx.x * blockDim.x + threadIdx.x ;
int8_t clk,re; int this_ram_number,ra; bool read_x_flag; 
if ( i < total_bits ) {
//figure ram parameters
  this_ram_number = ram_id[i]; bool write_x_flag =0; read_x_flag=0;
  int clk_address = clk_ra_re_ore_wa_we_bypsel_address[this_ram_number*address_space_width + 0]; clk = current_logic_value[clk_address];
  int ra_address = clk_ra_re_ore_wa_we_bypsel_address[this_ram_number*address_space_width + 1]; ra = 0; 
  int two_power =1;
  for (int j = 0 ; j < 12 ; j++ ) {
    int ra_address_deref = this_ram_number*address_space_width + 1 + j;
	ra_address = clk_ra_re_ore_wa_we_bypsel_address[ra_address_deref];
    if ( current_logic_value[ra_address] == 2 ) {
      read_x_flag = 1; break;
    }
	ra += current_logic_value[ra_address]*two_power;
    two_power *= 2;
  }
  int re_address = clk_ra_re_ore_wa_we_bypsel_address[this_ram_number*address_space_width + 13]; re = current_logic_value[re_address];
  if (clk==1) {
   int ore_address = clk_ra_re_ore_wa_we_bypsel_address[this_ram_number*address_space_width + 14]; int8_t ore = current_logic_value[ore_address];
   int wa_address = clk_ra_re_ore_wa_we_bypsel_address[this_ram_number*address_space_width + 15]; int wa = 0;
   two_power =1;
   for (int j = 0 ; j < 12 ; j++ ) {
     int wa_address_deref = this_ram_number*address_space_width + 15 + j;
	 wa_address = clk_ra_re_ore_wa_we_bypsel_address[wa_address_deref];
     if ( current_logic_value[wa_address] == 2 ) {
       write_x_flag = 1; break;
     }
	 wa += current_logic_value[wa_address]*two_power;
     two_power *= 2;
   }
   int we_address = clk_ra_re_ore_wa_we_bypsel_address[this_ram_number*address_space_width + 27]; int8_t we = current_logic_value[we_address];
   int bypsel_address = clk_ra_re_ore_wa_we_bypsel_address[this_ram_number*address_space_width + 28]; int8_t byp_sel = current_logic_value[bypsel_address];
   int8_t di = current_logic_value[di_address[i]]; int8_t dbyp = current_logic_value[dbyp_address[i]];
   int ram_col = i- ram_thread_breakpoints[this_ram_number] ;
   int ram_col_width = ram_col_widths[this_ram_number];
   int ram_start_address = M_breakpoints[this_ram_number];
   int ra_d_before = ra_d[this_ram_number]; int ra_d_local=ra_d_before;
   if (re==1 && ore==9) {
    ra_d_local = read_x_flag ? ra_x_address : ra;
   }
   if (we==1 && write_x_flag==0) {
    M_01[ram_start_address+wa*ram_col_width+ram_col] = di==1 ? 1 : 0;
    M_XZ[ram_start_address+wa*ram_col_width+ram_col] = di==2 ? 1 : 0;
   }
   int8_t previous_state = current_logic_value[dout_address[i]] ; 
   if ( ore == 1 ) {
    int8_t dout_ram = ra_d_before == ra_x_address ? 2 : int8_t(M_01[ram_start_address+ra_d_before*ram_col_width+ram_col]) + 2*int8_t(M_XZ[ram_start_address+ra_d_before*ram_col_width+ram_col]) ;
    int8_t fbypass_dout_ram = byp_sel==2 ? 2 :
	                          byp_sel==1 ? dbyp : dout_ram ; //this command assumes there's no unlatched version of bypass data
    current_logic_value[dout_address[i]] = fbypass_dout_ram;
   } else if ( ore == 9 ) {
    int8_t dout_ram =  ra_d_local == ra_x_address ? 2: int8_t(M_01[ram_start_address+ra_d_local*ram_col_width+ram_col]) + 2*int8_t(M_XZ[ram_start_address+ra_d_local*ram_col_width+ram_col]) ;
    int8_t fbypass_dout_ram = byp_sel==2 ? 2 :
	                          byp_sel==1 ? dbyp : dout_ram ; //this command assumes there's no unlatched version of bypass data
    current_logic_value[dout_address[i]] = fbypass_dout_ram;
   }
   if (previous_state != current_logic_value[dout_address[i]] ) {
     uint64_t vc_point =uint64_t(temp_active_timestamps[cycle]);
     int split = int(vc_point / fold_split);  numOfSwitchesPerDriverPerSplitRAMs[i*num_splits + split]++ ; 
	 vc_point = vc_point | (uint64_t(current_logic_value[dout_address[i]]) << 62) ;
	 vc_point = vc_point | (uint64_t(dout_address[i]) << 32) ; 
	 uint32_t vc_point_write_address = atomicAdd(&global_vc_write_pointer[0],1);
	 output_waveforms_storage[vc_point_write_address] = vc_point;
	}
  }
}
cooperative_groups::grid_group grid = cooperative_groups::this_grid();
grid.sync(); 
if ( i < total_bits ) {
  if (clk==1 && re==1 ) {
    ra_d[this_ram_number] = read_x_flag ? ra_x_address : ra;
  }
}
}
'''
simulate_rams=cp.RawKernel(kernel_src_code, 'simulate_rams', enable_cooperative_groups=True,backend='nvcc')
simulate_rams.compile() ;

kernel_src_code = r'''
extern "C" __global__
void map_FOs_to_thread_address( 
const long* FO_levels0,
const long* FO_levels1,
int* thread_address,
const int nodes_size, const int GPU_max_cooperative_threads, const int FO_levels1_size) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < nodes_size ) {
  int j=0; int mapper = -1;
  while( (mapper < 0) && (j < FO_levels1_size) ) {
    if(FO_levels0[i] == FO_levels1[j]) {
      mapper = j;
    }
    j++;
  }
  thread_address[i]=mapper;
}
}
'''
map_FOs_to_thread_address=cp.RawKernel(kernel_src_code, 'map_FOs_to_thread_address')
map_FOs_to_thread_address.compile() ;

kernel_src_code = r'''
extern "C" __global__
void map_drivers_to_thread_address( 
const int* active_indexes,
const int* num_of_FOs,
const int* FO_breakpoints,
int* which_threadID_to_read_from,
const int nodes_size) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < nodes_size ) {
  int this_index = active_indexes[i];
  int num_of_FO = num_of_FOs[this_index];
  for (int j=0; j< num_of_FO; j++) {
    which_threadID_to_read_from[FO_breakpoints[i]+j] = this_index;
  }
}
}
'''
map_drivers_to_thread_address=cp.RawKernel(kernel_src_code, 'map_drivers_to_thread_address')
map_drivers_to_thread_address.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__
void map_to_new_nodes( 
const int* old_nodes,
const int* new_node_order,
int* new_nodes,
const int nodes_size, const int graph_nodes_size) {
  const int i = blockIdx.x * blockDim.x + threadIdx.x ;
    if ( i < nodes_size ) {
  int mapper =0 ;
  for(int j=0; j< graph_nodes_size; j++) {
    if ( new_node_order[j] == old_nodes[i] ) {
      mapper = j;
    }
  }
  new_nodes[i] = mapper;
  }
}
'''
map_to_new_nodes=cp.RawKernel(kernel_src_code, 'map_to_new_nodes',backend='nvcc')
map_to_new_nodes.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__
void tie_some_highs( 
const int* mapped_tie_node_nums,
const int* in_edges9_indexes,
const int8_t* tie_pin_positions,
int* in_edges9, 
const int* seq_cell_types,
const int vdd_node,
const int num_of_ties) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
  if ( i < num_of_ties ) {
    int pin_position_index; //figure out the true pin position, figure out the true row column, then write a vdd_node. done.
    pin_position_index = int(tie_pin_positions[i]) - 1;
    if (seq_cell_types[mapped_tie_node_nums[i]] >= 300) {
        pin_position_index = (pin_position_index == 8) ? 6 : 
                             (pin_position_index == 6) ? 5 : pin_position_index ;
    }
	long row_index; row_index = in_edges9_indexes[i];
	in_edges9[row_index*8+pin_position_index] = vdd_node;
}
}
'''
tie_some_highs=cp.RawKernel(kernel_src_code, 'tie_some_highs',backend='nvcc')
tie_some_highs.compile() ;

kernel_src_code = r'''
extern "C" __global__
void figure_out_sync_or_async( 
const bool* sync_or_async_event,
const long* timestamp_counts,
bool* sync_or_async_event_processed, 
const int temp_active_timestamps_size) {
  const int i = blockDim.x * blockIdx.x + threadIdx.x;
  if (i < temp_active_timestamps_size ) {
    long ref_begin =0; bool async_or_sync = 0;
    for(int j=0; j < i; j++) {
      ref_begin += timestamp_counts[j];
    }
    for(int j=0; j < int(timestamp_counts[i]); j++ ) {
      async_or_sync = max(async_or_sync, sync_or_async_event[ref_begin +j]);
    }
    sync_or_async_event_processed[i] = async_or_sync;
  }
}
'''
figure_out_sync_or_async=cp.RawKernel(kernel_src_code, 'figure_out_sync_or_async')
figure_out_sync_or_async.compile() ;







kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void setFoldedRegisterPseudoInputs( 
const uint64_t* output_waveforms_storage,
const uint32_t* foldSplitBeginIndexes,
const uint32_t* perDriverPerSplitPointersBegin,
const uint32_t* perDriverPerSplitPointersEnd,
uint32_t* waveforms_total,
const int* nodes_list_gpu_seqs,
const int num_splits, const int num_of_drivers, const uint32_t fold_split, const uint32_t end_token) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
const int j = threadIdx.y;
uint32_t extracted_value, write_address;

if ( i < num_of_drivers ) {
  uint32_t this_driver = uint32_t(nodes_list_gpu_seqs[i]); 
  uint32_t thisOutputWaveformIndex = foldSplitBeginIndexes[j]; uint32_t theOutputWaveformEndIndex = foldSplitBeginIndexes[j+1];
  write_address = perDriverPerSplitPointersBegin[i*num_splits + j] + 1;
  while (thisOutputWaveformIndex < theOutputWaveformEndIndex ) {
    uint32_t extracted_driver = uint32_t((output_waveforms_storage[thisOutputWaveformIndex] & 0x3FFFFFFF00000000) >> 32);
	if (extracted_driver == this_driver) { 
	  extracted_value = uint32_t((output_waveforms_storage[thisOutputWaveformIndex] & 0xC000000000000000) >> 32);
	  uint32_t extracted_timestamp = uint32_t((output_waveforms_storage[thisOutputWaveformIndex] & 0x00000000FFFFFFFF));
	  extracted_timestamp -= (uint32_t)j * fold_split; extracted_timestamp  = extracted_timestamp | extracted_value;
	  waveforms_total[write_address]  = extracted_timestamp ; write_address++;
	}
	thisOutputWaveformIndex++;
  }
}
__syncthreads();
if ( i < num_of_drivers ) {
  if ( j ==0 ) { 
    write_address = perDriverPerSplitPointersBegin[i*num_splits]; 
	waveforms_total[write_address] = 2147483648; //should be 0?
  } else {
    int k = j;
    while ( (k > 1) && ((perDriverPerSplitPointersBegin[i*num_splits + k] -2) == perDriverPerSplitPointersBegin[i*num_splits + k-1]) ) {
      k--;
    }
    write_address = perDriverPerSplitPointersBegin[i*num_splits + k] -2 ; 
	extracted_value  = (waveforms_total[write_address] & 0xC0000000);
	write_address = perDriverPerSplitPointersBegin[i*num_splits + j]; waveforms_total[write_address] = extracted_value;
  }
  write_address = perDriverPerSplitPointersEnd[i*num_splits + j]-1;
  waveforms_total[write_address] = end_token;
}
}
'''
setFoldedRegisterPseudoInputs=cp.RawKernel(kernel_src_code, 'setFoldedRegisterPseudoInputs', backend='nvcc')
setFoldedRegisterPseudoInputs.compile() ;



kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__
void setPushoutDelays( 
const uint32_t* pushout_rise,
const uint32_t* pushout_fall,
uint32_t* pushout_delays, 
const int nodes_size) {
const int i = blockDim.x * blockIdx.x + threadIdx.x;
if ( i < nodes_size ) {
 //if ( isClkTree[i] == 0 ) { pushout_delays[i] = (pushout_fall[i]) | (pushout_rise[i] << 16); } 
 //else { pushout_delays[i] = 0 ; }
 pushout_delays[i] = (pushout_fall[i]) | (pushout_rise[i] << 16);
}
}
'''
setPushoutDelays=cp.RawKernel(kernel_src_code, 'setPushoutDelays', backend='nvcc')
setPushoutDelays.compile() ;


kernel_src_code = r'''
extern "C" __global__
void set_inputs( 
const int cycle,
const int8_t* input_values_array, 
int8_t* current_logic_value,
const int* nodes_num,
const int nodes_size,
const int cycles) {
 const int tid_x = blockDim.x * blockIdx.x + threadIdx.x;
  if (tid_x < nodes_size ) {
    current_logic_value[nodes_num[tid_x]] = input_values_array[tid_x * cycles + cycle];
  }
}
'''
set_inputs=cp.RawKernel(kernel_src_code, 'set_inputs',backend='nvcc',options = ('-lineinfo',))
set_inputs.compile() ;


kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__
void organize_input_addresses_for_seqs( 
const int* first_level_inputs_list,
const int8_t* pin_positions,
const int8_t* in_degs, 
int* in_edges9, 
const int* seq_cell_types,
const int gnd_node,
const int nodes_size) {
  const int i = blockDim.x * blockIdx.x + threadIdx.x;
  if (i < nodes_size ) {
     int ref_begin = 0; int pin_position_index;
    for(int j =0; j<i; j++) {
      ref_begin += int(in_degs[j]);
    }  
	for (int j =0 ; j < int(in_degs[i]) ; j++ ) {
	  pin_position_index = int(pin_positions[ref_begin+j]) - 1;
      if (seq_cell_types[i] >= 300) {
        in_edges9[i*8+5] = gnd_node;
        pin_position_index = (pin_position_index == 8) ? 6 : 
                             (pin_position_index == 6) ? 5 : pin_position_index ;
																				 
      }
      in_edges9[i*8+pin_position_index] = first_level_inputs_list[ref_begin+j];
	}
}
}
'''
organize_input_addresses_for_seqs=cp.RawKernel(kernel_src_code, 'organize_input_addresses_for_seqs',backend='nvcc')
organize_input_addresses_for_seqs.compile() ;

kernel_src_code = r'''
extern "C" __global__
void store_previous_states3d( 
int8_t* previous_states,
int8_t* current_logic_value, 
const int* seq_nodes_list,
const int nodes_size) {
  const int i = blockDim.x * blockIdx.x + threadIdx.x;
  if (i < nodes_size) {
    previous_states[i] = current_logic_value[seq_nodes_list[i]] ;
  }
}
'''
store_previous_states3d=cp.RawKernel(kernel_src_code, 'store_previous_states3d',backend='nvcc')
store_previous_states3d.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <cooperative_groups.h>
extern "C" __global__
void simulate_reg2combo_interface( 
const int* next_stage_write_addresses_list,
const int8_t* pin_positions_list,
int8_t* current_logic_value, 
int8_t* register_combo_interface_previous_states,
const int* nodes_list_gpu,
const int* which_threadID_to_read_from,
int* theres_an_event,
int* per_thread_msg,
int8_t* per_node_activity,
const int num_edges_this_stage, const int num_nodes_this_stage, const int GPU_max_cooperative_threads) {
const int i = blockDim.x * blockIdx.x + threadIdx.x; 
cooperative_groups::grid_group grid = cooperative_groups::this_grid();
int node_position=i;
while ( node_position<num_nodes_this_stage  ) {
  int this_node_num = nodes_list_gpu[node_position] ;
  int8_t value_change = current_logic_value[this_node_num] - register_combo_interface_previous_states[node_position];
  if ( value_change != 0 ) {
    theres_an_event[0]=1;
    register_combo_interface_previous_states[node_position]=current_logic_value[this_node_num];
  }
  per_node_activity[node_position] = value_change;
  node_position += GPU_max_cooperative_threads ;
}
grid.sync();
//now do per thread writing of messages for the next stage
int edge_position = i;
while ( edge_position < num_edges_this_stage) {
  int this_node_position_num = which_threadID_to_read_from[edge_position];
  int8_t value_change_to_write = per_node_activity[this_node_position_num];
  if (value_change_to_write != 0 ) {
    int write_address = next_stage_write_addresses_list[edge_position];
    int pin_position = int(pin_positions_list[edge_position]);
    int msg=0;
    msg = ( msg | (1 << 24) ) ;
    msg = (value_change_to_write < 0) ? ( msg | (1 << (pin_position*3+2)) ) : msg ;
    msg = (value_change_to_write%2==0) ? ( msg | (1 << (pin_position*3+1)) ) : ( msg | (1 << (pin_position*3)) ) ;
    atomicOr(&per_thread_msg[write_address], msg);
  }
  edge_position += GPU_max_cooperative_threads ;
}
}
'''
simulate_reg2combo_interface=cp.RawKernel(kernel_src_code, 'simulate_reg2combo_interface',options=('-lineinfo',), enable_cooperative_groups=True,backend='nvcc')
simulate_reg2combo_interface.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void extract_time_stamps( 
const uint64_t* output_waveforms_storage,
uint32_t* extracted_time_stamps,
const int num_of_timestamps) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < num_of_timestamps ) {
  extracted_time_stamps[i] = uint32_t(output_waveforms_storage[i] & 0x00000000FFFFFFFF);
}
}
'''
extract_time_stamps=cp.RawKernel(kernel_src_code, 'extract_time_stamps',backend='nvcc')
extract_time_stamps.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void extractNumOfSwitchesPerDriverPerSplit( 
const uint64_t* output_waveforms_storage,
const uint32_t* foldSplitBeginIndexes,
uint32_t* numOfSwitchesPerDriverPerSplit,
const int* nodes_list_gpu_seqs,
const int num_splits, const int num_of_drivers) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
const int j = threadIdx.y;

if ( i < num_of_drivers ) {
  int this_driver = nodes_list_gpu_seqs[i]; 
  uint32_t thisOutputWaveformIndex = foldSplitBeginIndexes[j]; uint32_t theOutputWaveformEndIndex = foldSplitBeginIndexes[j+1];
  numOfSwitchesPerDriverPerSplit[i*num_splits + j] = 1;
  while (thisOutputWaveformIndex < theOutputWaveformEndIndex ) {
    int extracted_driver = int((output_waveforms_storage[thisOutputWaveformIndex] & 0x3FFFFFFF00000000) >> 32);
	if (extracted_driver == this_driver) { numOfSwitchesPerDriverPerSplit[i*num_splits + j]++ ; };
	thisOutputWaveformIndex++;
  }
}
}
'''
extractNumOfSwitchesPerDriverPerSplit=cp.RawKernel(kernel_src_code, 'extractNumOfSwitchesPerDriverPerSplit',backend='nvcc')
extractNumOfSwitchesPerDriverPerSplit.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateT0s( 
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
uint64_t* T0s,
uint32_t* subtractTCs,
const int num_splits, const int num_nodes, const uint32_t fold_split, const uint64_t sim_duration ) {
const int threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const int i = (threadID / num_splits) ; const int k = (threadID % num_splits) ;
if ( i < num_nodes  ) {
 uint64_t extracted_value, extracted_time, current_time, current_value, previous_value, endOfSplit; uint32_t vc;
 int64_t thisGATSPIPointerCurrent = perNodePerSplitWaveformPointerStart[i*num_splits+k];
 int64_t thisGATSPIPointerEnd = perNodePerSplitWaveformPointerEnd[i*num_splits+k];
 uint64_t timeOffset = uint64_t(uint64_t(fold_split) * uint64_t(k));
 endOfSplit = (k==31) ? sim_duration : timeOffset + uint64_t(fold_split);
 vc = new_waveforms_total[ thisGATSPIPointerCurrent ] ;
 current_value  = uint64_t((vc & 0xC0000000) >> 30); current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 extracted_value = current_value ; extracted_time = current_time; previous_value = 9;
 int search_split = k-1;
 while ( search_split >= 0 ) {
  if ( (perNodePerSplitWaveformPointerEnd[i*num_splits + search_split] - perNodePerSplitWaveformPointerStart[i*num_splits + search_split]) > 2 ) {
   break;
  } else {
   search_split--;
  }
 }
 if (search_split >= 0 ) {
   vc = new_waveforms_total[ perNodePerSplitWaveformPointerEnd[ i*num_splits + search_split ] - 3 ] ;
   previous_value = uint64_t((vc & 0xC0000000) >> 30);
 }
 thisGATSPIPointerCurrent++;
 for (int64_t j = thisGATSPIPointerCurrent ; j < (thisGATSPIPointerEnd-1) ; j++ ) {
  vc = new_waveforms_total[ j ] ;
  extracted_value  = uint64_t((vc & 0xC0000000) >> 30); extracted_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  if ( current_value != 1) {
   T0s[ i*num_splits + k ] += extracted_time - current_time ; 
  }
  if ((extracted_value == 2) || ((current_value==2) && ((previous_value == extracted_value) || (previous_value == 9)))) { subtractTCs[ i*num_splits + k ]++;}
  previous_value = current_value ; current_value  = extracted_value; current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 }
 //Add the last switch to fold_split T0, T1, TX values.
 if ( current_value != 1 ) {
  T0s[ i*num_splits + k ] +=  endOfSplit - current_time ; 
 }
}
}
'''
calculateT0s=cp.RawKernel(kernel_src_code, 'calculateT0s', backend='nvcc')
calculateT0s.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateT0sLastSubchunk( 
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
uint64_t* T0s,
uint32_t* subtractTCs,
const int num_splits, const int num_nodes, const uint32_t fold_split, const uint64_t sim_duration, const uint64_t totalSimDuration, const uint64_t subchunkStartTime ) {
const int threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const int i = (threadID / num_splits) ; const int k = (threadID % num_splits) ;
if ( i < num_nodes  ) {
 uint64_t extracted_value, extracted_time, current_time, current_value, endOfSplit, previous_value; uint32_t vc;
 int64_t thisGATSPIPointerCurrent = perNodePerSplitWaveformPointerStart[i*num_splits+k];
 int64_t thisGATSPIPointerEnd = perNodePerSplitWaveformPointerEnd[i*num_splits+k];
 uint64_t timeOffset = uint64_t(uint64_t(fold_split) * uint64_t(k));
 endOfSplit = (k==31) ? totalSimDuration : timeOffset + uint64_t(fold_split);
 timeOffset = (k==31) ? timeOffset + subchunkStartTime : timeOffset;
 vc = new_waveforms_total[ thisGATSPIPointerCurrent ] ;
 current_value  = uint64_t((vc & 0xC0000000) >> 30); current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 extracted_value = current_value ; extracted_time = current_time; previous_value = 9;
 int search_split = k-1;
 while ( search_split >= 0 ) {
  if ( (perNodePerSplitWaveformPointerEnd[i*num_splits + search_split] - perNodePerSplitWaveformPointerStart[i*num_splits + search_split]) > 2 ) {
   break;
  } else {
   search_split--;
  }
 }
 if (search_split >= 0 ) {
   vc = new_waveforms_total[ perNodePerSplitWaveformPointerEnd[ i*num_splits + search_split ] - 3 ] ;
   previous_value = uint64_t((vc & 0xC0000000) >> 30);
 }
 thisGATSPIPointerCurrent++;
 for (int64_t j = thisGATSPIPointerCurrent ; j < (thisGATSPIPointerEnd-1) ; j++ ) {
  vc = new_waveforms_total[ j ] ;
  extracted_value  = uint64_t((vc & 0xC0000000) >> 30); extracted_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  if (( current_value != 1) && (extracted_time < totalSimDuration)) {
   T0s[ i*num_splits + k ] += extracted_time - current_time ; 
  } else if (( current_value != 1) && (extracted_time >= totalSimDuration) && (current_time < totalSimDuration)) {
   T0s[ i*num_splits + k ] += totalSimDuration - current_time ; subtractTCs[ i*num_splits + k ]++;
  } else if (extracted_time >= totalSimDuration) {
   subtractTCs[ i*num_splits + k ]++;
  }
  if (((extracted_value == 2) || ((current_value==2) && ((previous_value == extracted_value) || (previous_value==9)))) && (extracted_time < totalSimDuration)) { subtractTCs[ i*num_splits + k ]++;}
  previous_value = current_value ; current_value  = extracted_value; current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 }
 //Add the last switch to fold_split T0, T1, TX values.
 if ( (current_value != 1) && (current_time <= totalSimDuration) ) {
  T0s[ i*num_splits + k ] +=  endOfSplit - current_time ; 
 }
}
}
'''
calculateT0sLastSubchunk=cp.RawKernel(kernel_src_code, 'calculateT0sLastSubchunk', backend='nvcc')
calculateT0sLastSubchunk.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void getCondValues( 
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
uint8_t* cond_values_array,
int64_t change_list_size, int64_t nodes_size, int64_t num_splits, uint32_t end_token ) {
const int64_t threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const int64_t i = (threadID / num_splits) ; const int64_t k = (threadID % num_splits) ;
if ( i < nodes_size  ) {
 uint32_t Timechange, condTimechange, condValue; int64_t Timechange_pointer; int64_t Timechange_pointer_offset = 0; int64_t cond_pointer_offset = 0;
 Timechange_pointer = perNodePerSplitWaveformPointerStart[k] + 1 ;
 uint32_t vc = new_waveforms_total[ Timechange_pointer ] ;
 Timechange = (vc & 0x3FFFFFFF) ;
 uint32_t vcCond = new_waveforms_total[ perNodePerSplitWaveformPointerStart[i*num_splits + k] + cond_pointer_offset ] ;
 condTimechange = (vcCond & 0x3FFFFFFF) ;
 while (Timechange != end_token) {
  while ( (condTimechange < Timechange) || ( condTimechange==0 && Timechange==0 ) ) {
   cond_pointer_offset++;
   vcCond = new_waveforms_total[ perNodePerSplitWaveformPointerStart[i*num_splits + k] + cond_pointer_offset ] ;
   condTimechange = (vcCond & 0x3FFFFFFF) ;
  }
  vcCond = new_waveforms_total[ perNodePerSplitWaveformPointerStart[i*num_splits + k] + cond_pointer_offset - 1 ] ;
  condValue = ((vcCond & 0xC0000000) >> 30); condValue = (condValue==2) ? 0 : condValue ;
  cond_values_array[ i*change_list_size + Timechange_pointer_offset + perNodePerSplitWaveformPointerStart[k] - perNodePerSplitWaveformPointerStart[0] - 2*k ] = uint8_t(condValue) ;
  Timechange_pointer_offset++;
  vc = new_waveforms_total[ Timechange_pointer + Timechange_pointer_offset ] ;
  Timechange = (vc & 0x3FFFFFFF) ; 
 }
}
}
'''
getCondValues=cp.RawKernel(kernel_src_code, 'getCondValues', backend='nvcc')
getCondValues.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void reconstructWholeWaveforms( 
const uint32_t* new_waveforms_total,
uint64_t* wholeWaveformTempStorage,
const uint32_t* perNodeWholeWaveformPointers,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
uint64_t* T0T1TXTimes,
const int num_splits, const int num_nodes, const uint32_t fold_split, const uint64_t sim_duration, const int subchunk_id ) {
const int threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const int i = (threadID / num_splits) ; const int k = (threadID % num_splits) ;
if ( i < num_nodes  ) {
 uint64_t extracted_value, extracted_time, current_time, current_value, second_value; uint32_t vc;
 second_value = subchunk_id==0 ? 3 : 4; int search_split = k-1;
 while ( search_split >= 0 ) {
  if ( (perNodePerSplitWaveformPointerEnd[i*num_splits + search_split] - perNodePerSplitWaveformPointerStart[i*num_splits + search_split]) > 2 ) {
   break;
  } else {
   search_split--;
  }
 }
 if (search_split >= 0 ) {
   vc = new_waveforms_total[ perNodePerSplitWaveformPointerEnd[ i*num_splits + search_split ] - 3 ] ;
   second_value = uint64_t((vc & 0xC0000000) >> 30);
 }
 int64_t thisGATSPIPointerCurrent = perNodePerSplitWaveformPointerStart[i*num_splits+k];
 int64_t thisGATSPIPointerEnd = perNodePerSplitWaveformPointerEnd[i*num_splits+k];
 uint64_t timeOffset = uint64_t(uint64_t(fold_split) * uint64_t(k));
 uint32_t thisWholeWaveformPointerStartOffset = uint32_t(thisGATSPIPointerCurrent - perNodePerSplitWaveformPointerStart[i*num_splits])  - (2*uint32_t(k)) + 1;
 uint32_t thisWholeWaveformPointerStart = perNodeWholeWaveformPointers[i] + thisWholeWaveformPointerStartOffset ;
 thisWholeWaveformPointerStart = (k==0)? thisWholeWaveformPointerStart-1 : thisWholeWaveformPointerStart ;
 vc = new_waveforms_total[ thisGATSPIPointerCurrent ] ;
 current_value  = uint64_t((vc & 0xC0000000) >> 30); current_time = uint64_t(vc & 0x3FFFFFFF) ;
 extracted_value = current_value ; extracted_time = current_time + timeOffset;
 if (k==0) {
  vc = new_waveforms_total[ thisGATSPIPointerCurrent ] ;
  extracted_value  = uint64_t((vc & 0xC0000000) >> 30); extracted_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  wholeWaveformTempStorage[thisWholeWaveformPointerStart] = extracted_time | (extracted_value << 62) ; thisWholeWaveformPointerStart++;
 }
 thisGATSPIPointerCurrent++;
 for (int64_t j = thisGATSPIPointerCurrent ; j < (thisGATSPIPointerEnd-1) ; j++ ) {
  vc = new_waveforms_total[ j ] ;
  extracted_value  = uint64_t((vc & 0xC0000000) >> 30); extracted_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  wholeWaveformTempStorage[thisWholeWaveformPointerStart] = extracted_time | (extracted_value << 62) ; thisWholeWaveformPointerStart++;
  T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += uint64_t(vc & 0x3FFFFFFF) - current_time ; 
  if ((current_value == 2) && (second_value == extracted_value)) { T0T1TXTimes[i*5*num_splits + k*5 + 4 ]++ ;}
  else if ((current_value == 2) && (second_value != extracted_value) && (second_value != 3) ) { T0T1TXTimes[i*5*num_splits + k*5 + 3 ]++ ;}
  else if ( (extracted_value != 2) && (second_value != 3) ) { T0T1TXTimes[i*5*num_splits + k*5 + 3 ]++ ;}
  second_value = current_value; current_value  = extracted_value; current_time = uint64_t(vc & 0x3FFFFFFF) ;
 }
 //Add the last switch to fold_split T0, T1, TX values.
  if (k!= 31) { T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += uint64_t(fold_split) - current_time ; }
  else { T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += sim_duration - extracted_time ; }
}
}
'''
reconstructWholeWaveforms=cp.RawKernel(kernel_src_code, 'reconstructWholeWaveforms', backend='nvcc')
reconstructWholeWaveforms.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void getSAIFForTimestampRegion( 
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
uint64_t* T0T1TXTimes,
const int num_splits, const int num_nodes, const uint32_t fold_split, const uint64_t sim_duration, const uint64_t timeStart, const uint64_t timeEnd, const int subchunk_id ) {
const int threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const int i = (threadID / num_splits) ; const int k = (threadID % num_splits) ;
if ( i < num_nodes  ) {
 uint64_t extracted_value, extracted_time, current_time, current_value, second_value, highAnchor, lowAnchor, endOfSplit; uint32_t vc;
 int search_split = k-1; highAnchor = 0; lowAnchor = 0;
 while ( search_split >= 0 ) {
  if ( (perNodePerSplitWaveformPointerEnd[i*num_splits + search_split] - perNodePerSplitWaveformPointerStart[i*num_splits + search_split]) > 2 ) {
   break;
  } else {
   search_split--;
  }
 }
 if (search_split >= 0 ) {
   vc = new_waveforms_total[ perNodePerSplitWaveformPointerEnd[ i*num_splits + search_split ] - 3 ] ;
   second_value = uint64_t((vc & 0xC0000000) >> 30);
 }
 int64_t thisGATSPIPointerCurrent = perNodePerSplitWaveformPointerStart[i*num_splits+k];
 int64_t thisGATSPIPointerEnd = perNodePerSplitWaveformPointerEnd[i*num_splits+k];
 uint64_t timeOffset = uint64_t(uint64_t(fold_split) * uint64_t(k));
 endOfSplit = (k==31) ? sim_duration : timeOffset + uint64_t(fold_split);
 vc = new_waveforms_total[ thisGATSPIPointerCurrent ] ;
 current_value  = uint64_t((vc & 0xC0000000) >> 30); current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 second_value = search_split < 0 ? current_value : second_value;
 extracted_value = current_value ; extracted_time = current_time;
 thisGATSPIPointerCurrent++;
 for (int64_t j = thisGATSPIPointerCurrent ; j < (thisGATSPIPointerEnd-1) ; j++ ) {
  vc = new_waveforms_total[ j ] ;
  extracted_value  = uint64_t((vc & 0xC0000000) >> 30); extracted_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  if ((current_time >= timeStart) && (current_time <= timeEnd)) {
   lowAnchor = max(current_time, timeStart); highAnchor = min(extracted_time, timeEnd);
   T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += highAnchor - lowAnchor ; 
  } else if ((current_time <= timeStart) && (extracted_time >= timeEnd)) {
   T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += timeEnd - timeStart ;
  }
  if ((extracted_time >= timeStart) && (extracted_time <= timeEnd)) {
   if ((current_value == 2) && (second_value == extracted_value)) { T0T1TXTimes[i*5*num_splits + k*5 + 4 ]++ ;}
   else if ((current_value == 2) && (second_value != extracted_value) && (second_value != 2) ) { T0T1TXTimes[i*5*num_splits + k*5 + 3 ]++ ;}
   else if ( (extracted_value != 2) && !((second_value == 2) && (second_value == current_value)) ) { T0T1TXTimes[i*5*num_splits + k*5 + 3 ]++ ;}
  }
   second_value = current_value; current_value  = extracted_value; current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 }
 //Add the last switch to fold_split T0, T1, TX values.
 if ((current_time >= timeStart) && (current_time <= timeEnd)) {
  lowAnchor = max(current_time, timeStart); highAnchor = min(endOfSplit, timeEnd);
  T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += highAnchor - lowAnchor ; 
 } else if ((current_time <= timeStart) && (endOfSplit >= timeEnd)) {
   T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += timeEnd - timeStart ;
 }
}
}
'''
getSAIFForTimestampRegion=cp.RawKernel(kernel_src_code, 'getSAIFForTimestampRegion', backend='nvcc')
getSAIFForTimestampRegion.compile() ;


kernel_src_code = r'''
#include <stdint.h>
#include <vector>
#include <math.h>
#include <float.h>
#include <algorithm>
#include <cstdlib>
extern "C" __global__ void simulate_gate_TC( 
uint32_t* new_waveforms_total,
const uint32_t* full_delays,
const uint32_t* X_delays,
const int8_t* out_tables_cp,
const uint32_t* celltypes,
const uint8_t* in_degs,
const uint32_t* edge_breakpoints,
const uint32_t* net_delays_rise,
const uint32_t* net_delays_fall,
const uint32_t* XCond_pointers,
const uint8_t* pin_positions,
const uint32_t* delay_pointer_start,
const uint32_t* delay_pointer_end,
int64_t* waveform_pointers,
uint32_t* output_TC,
uint32_t nodes_size, uint32_t num_splits, uint32_t end_token, uint32_t end_token_timestamp, int8_t simTime0Flag) {
const uint32_t threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const uint32_t i = (threadID / num_splits) ; const uint32_t k = (threadID % num_splits) ;
if ( i < nodes_size  ) {
  uint32_t extracted_value;
  uint32_t ref_begin=edge_breakpoints[i]; uint32_t input_pins = uint32_t(in_degs[i]);
  uint32_t gate_LUT_col=0; uint32_t gate_LUT_col2=0; uint32_t SDF_split ;
  int8_t initTimestamp = simTime0Flag && (k==0) ;							   
  for ( uint32_t j=0; j< input_pins ; j++ ) {
   if (initTimestamp) {
    waveform_pointers[(ref_begin+j)*num_splits + k]--;
   } else {
    extracted_value  = (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] ] & 0xC0000000) >> 30;
    gate_LUT_col += extracted_value  * uint32_t( pow(3, pin_positions[ref_begin + j] ) + 1e-9 ) ;
   }
  }
  int8_t init_val = initTimestamp ? 2 : out_tables_cp[celltypes[i]*6561 + gate_LUT_col] ; uint32_t init_time = 0; uint32_t init_time2= 0;
  int8_t init_val2 = init_val; 												
  uint32_t trans_time = 0; int8_t y; uint32_t delay_used; uint32_t output_trans_time; uint32_t net_delay = 0; 
  while (trans_time != end_token_timestamp) {
  // for (int z= 0 ; z< 1204000; z++) {
    trans_time = end_token_timestamp; 
    for (uint32_t j =0; j < input_pins ; j++ ) {
      extracted_value  = (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] + 1 ] & 0xC0000000) >> 30;
      net_delay = (extracted_value==0) ? net_delays_fall[ref_begin+j] :
	            (extracted_value==1) ? net_delays_rise[ref_begin+j] : min(net_delays_fall[ref_begin+j], net_delays_rise[ref_begin+j]) ;
      //add proc to check if the interconnect does "BUFFER" inertial delay filtering
      if ( (new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 1] & 0x3FFFFFFF) < end_token_timestamp ) {
        if ( ((new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 2] & 0x3FFFFFFF) - 
	          (new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 1] & 0x3FFFFFFF)) < net_delay ) {
          waveform_pointers[(ref_begin+j)*num_splits  + k] += 2;
          j=-1 ; continue;
        }
      }
      trans_time = min( trans_time, (new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits + k]+1] & 0x3FFFFFFF) + net_delay ) ;
    }
    if (trans_time != end_token_timestamp) {
      uint32_t delay_used_rise = 999000; uint32_t delay_used_fall = 999000; uint8_t xMask =0;
      gate_LUT_col=0; gate_LUT_col2=0;
      for (uint32_t j =0 ; j < input_pins ; j++) {
        extracted_value  = (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] + 1 ] & 0xC0000000) >> 30;
        net_delay = (extracted_value==0) ? net_delays_fall[ref_begin+j] :
	            (extracted_value==1) ? net_delays_rise[ref_begin+j] : min(net_delays_fall[ref_begin+j], net_delays_rise[ref_begin+j]) ;
        extracted_value = ( ((new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 1] & 0x3FFFFFFF) + net_delay) == trans_time ) ? 
		                  (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] + 1 ] & 0xC0000000) >> 30 : 
						  (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] ] & 0xC0000000) >> 30 ;
        gate_LUT_col +=  extracted_value  * uint32_t( pow(3, pin_positions[ref_begin + j] ) + 1e-9 ) ;
        gate_LUT_col2 =  (extracted_value==1) ? gate_LUT_col2 + uint32_t( pow(2, pin_positions[ref_begin + j] ) + 1e-9 ) : gate_LUT_col2 ;
        if ( extracted_value == 2 ) { xMask = (xMask | ( uint8_t(1) << j )); } ;
	  }
      for (uint32_t j =0 ; j < input_pins ; j++) {
		uint8_t xMask_temp = 0;         extracted_value  = (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] + 1 ] & 0xC0000000) >> 30;
        net_delay = (extracted_value==0) ? net_delays_fall[ref_begin+j] :
	            (extracted_value==1) ? net_delays_rise[ref_begin+j] : min(net_delays_fall[ref_begin+j], net_delays_rise[ref_begin+j]) ;
        if ( ((new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 1] & 0x3FFFFFFF) + net_delay) == trans_time ) {
          waveform_pointers[(ref_begin+j)*num_splits + k]++; SDF_split = ( delay_pointer_end[ref_begin+j] - delay_pointer_start[ref_begin+j] )/4 ;
		  xMask_temp = xMask & ( ~(uint8_t(1) << j)) ; 
          if ( (((new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] ] & 0xC0000000) >> 30) == 0 ) ||
		       (((new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] - 1 ] & 0xC0000000) >> 30) == 1 ) ) {
            if (xMask_temp == 0) {
             delay_used_rise = min( delay_used_rise, full_delays[ delay_pointer_start[ref_begin+j] + ( 1 * SDF_split ) + gate_LUT_col2 ] ) ;
             delay_used_fall = min( delay_used_fall, full_delays[ delay_pointer_start[ref_begin+j] + ( 3 * SDF_split ) + gate_LUT_col2 ] ) ;
			} else {
             delay_used_rise = min( delay_used_rise, X_delays[ XCond_pointers[ref_begin+j]*4 + 1 ] ) ;
             delay_used_fall = min( delay_used_fall, X_delays[ XCond_pointers[ref_begin+j]*4 + 3 ] ) ;
           }
         } else {
            if ( xMask_temp == 0 ) {
             delay_used_rise = min( delay_used_rise, full_delays[ delay_pointer_start[ref_begin+j] + ( 0 * SDF_split ) + gate_LUT_col2 ] ) ;
             delay_used_fall = min( delay_used_fall, full_delays[ delay_pointer_start[ref_begin+j] + ( 2 * SDF_split ) + gate_LUT_col2 ] ) ;
            } else {
             delay_used_rise = min( delay_used_rise, X_delays[ XCond_pointers[ref_begin+j]*4 + 0 ] ) ;
             delay_used_fall = min( delay_used_fall, X_delays[ XCond_pointers[ref_begin+j]*4 + 2 ] ) ;
            }
         }
        }
      }
      y = out_tables_cp[celltypes[i]*6561 + gate_LUT_col] ;
      if ( (y==0) && (init_val != 0) && (delay_used_fall != 999000) ||
           (y!=1) && (init_val == 1) && (delay_used_fall != 999000) ||
           (y==1) && (init_val != 1) && (delay_used_rise != 999000) ||
           (y!=0) && (init_val == 0) && (delay_used_rise != 999000) ) {
		delay_used =  ((init_val == 0) || (y == 1)) ? delay_used_rise : delay_used_fall;
        output_trans_time = trans_time + delay_used;
        //add some if/else to filter out small x pulses. I call the principle 'rule of finality'
        if ( (output_trans_time  < (delay_used + init_time)) && (((init_val2 != 2) && (init_val != 2) && (y != 2) ) || ((init_val2 == y))) ) {
          output_TC[i*num_splits + k] -= 1; init_time = init_time2; init_val = init_val2;
        } else if ( (output_trans_time  < (delay_used + init_time)) && (init_val2 != y) ) {
		  init_time = output_trans_time; init_val = y;
		}
		 else {
          output_TC[i*num_splits + k] += 1; init_time2 = init_time ; init_time = output_trans_time; 
		  init_val2 = init_val; init_val=y;
																				   
        }
      }
	}
  }
			 
											
											   
}
}
'''
simulate_gate_TC=cp.RawKernel(kernel_src_code, 'simulate_gate_TC', backend='nvcc')
simulate_gate_TC.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <vector>
#include <math.h>
#include <float.h>
#include <algorithm>
#include <cstdlib>
extern "C" __global__ void simulate_gate_GATSPI( 
uint32_t* new_waveforms_total,
const uint32_t* full_delays,
const uint32_t* X_delays,					 
const int8_t* out_tables_cp,
const uint32_t* celltypes,
const uint8_t* in_degs,
const uint32_t* edge_breakpoints,
const uint32_t* net_delays_rise,
const uint32_t* net_delays_fall,
const uint32_t* XCond_pointers,						   
const uint8_t* pin_positions,
const uint32_t* delay_pointer_start,
const uint32_t* delay_pointer_end,
int64_t* waveform_pointers,
int64_t* output_pointers,
uint32_t nodes_size, uint32_t num_splits, uint32_t end_token, uint32_t end_token_timestamp, int8_t simTime0Flag) {
const uint32_t threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const uint32_t i = (threadID / num_splits) ; const uint32_t k = (threadID % num_splits) ;
if ( i < nodes_size  ) {
  uint32_t extracted_value;
  uint32_t ref_begin=edge_breakpoints[i]; uint32_t input_pins = uint32_t(in_degs[i]);
  uint32_t gate_LUT_col=0; uint32_t gate_LUT_col2=0; uint32_t SDF_split ; int64_t output_p;
  output_p = output_pointers[i*num_splits + k];
  int8_t initTimestamp = simTime0Flag && (k==0) ;
  for ( uint32_t j=0; j< input_pins ; j++ ) {
   if (initTimestamp) {
    waveform_pointers[(ref_begin+j)*num_splits + k]--;
   } else {					   												 	   
    extracted_value  = (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] ] & 0xC0000000) >> 30;
    gate_LUT_col += extracted_value  * uint32_t( pow(3, pin_positions[ref_begin + j] ) + 1e-9 ) ;
   }	
  }
  int8_t init_val = initTimestamp ? 2 : out_tables_cp[celltypes[i]*6561 + gate_LUT_col] ; uint32_t init_time = 0; uint32_t init_time2= 0;
  int8_t init_val2 = init_val; 
  new_waveforms_total[output_p] = uint32_t(init_val) << 30 ;
  uint32_t trans_time = 0; int8_t y;  uint32_t delay_used; uint32_t output_trans_time; uint32_t net_delay = 0; 
  while (trans_time != end_token_timestamp) {								   
    trans_time = end_token_timestamp;
    for (uint32_t j =0; j < input_pins ; j++ ) {
      extracted_value  = (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] + 1 ] & 0xC0000000) >> 30;
      net_delay = (extracted_value==0) ? net_delays_fall[ref_begin+j] :
	            (extracted_value==1) ? net_delays_rise[ref_begin+j] : min(net_delays_fall[ref_begin+j], net_delays_rise[ref_begin+j]) ;
      //add proc to check if the interconnect does "BUFFER" inertial delay filtering
      if ( (new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 1] & 0x3FFFFFFF) < end_token_timestamp ) {
        if ( ((new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 2] & 0x3FFFFFFF) - 
	          (new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 1] & 0x3FFFFFFF)) < net_delay ) {
          waveform_pointers[(ref_begin+j)*num_splits  + k] += 2;
          j=-1 ; continue;
        }
      }
      trans_time = min( trans_time, (new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits + k]+1] & 0x3FFFFFFF) + net_delay ) ;
    }
    if (trans_time != end_token_timestamp) {
      uint32_t delay_used_rise = 999000; uint32_t delay_used_fall = 999000; uint8_t xMask =0;
      gate_LUT_col=0; gate_LUT_col2=0;
      for (uint32_t j =0 ; j < input_pins ; j++) {
        extracted_value  = (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] + 1 ] & 0xC0000000) >> 30;
        net_delay = (extracted_value==0) ? net_delays_fall[ref_begin+j] :
	            (extracted_value==1) ? net_delays_rise[ref_begin+j] : min(net_delays_fall[ref_begin+j], net_delays_rise[ref_begin+j]) ;
        extracted_value = ( ((new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 1] & 0x3FFFFFFF) + net_delay) == trans_time ) ? 
		                  (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] + 1 ] & 0xC0000000) >> 30 : 
						  (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] ] & 0xC0000000) >> 30 ;
        gate_LUT_col +=  extracted_value  * uint32_t( pow(3, pin_positions[ref_begin + j] ) + 1e-9 ) ;
        gate_LUT_col2 =  (extracted_value==1) ? gate_LUT_col2 + uint32_t( pow(2, pin_positions[ref_begin + j] ) + 1e-9 ) : gate_LUT_col2 ;
        if ( extracted_value == 2 ) { xMask = (xMask | ( uint8_t(1) << j )); } ;																			 
	  }
      for (uint32_t j =0 ; j < input_pins ; j++) {
		uint8_t xMask_temp = 0; extracted_value  = (new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] + 1 ] & 0xC0000000) >> 30;	
        net_delay = (extracted_value==0) ? net_delays_fall[ref_begin+j] :
	            (extracted_value==1) ? net_delays_rise[ref_begin+j] : min(net_delays_fall[ref_begin+j], net_delays_rise[ref_begin+j]) ;		
        if ( ((new_waveforms_total[waveform_pointers[(ref_begin+j)*num_splits  + k] + 1] & 0x3FFFFFFF) + net_delay) == trans_time ) {
          waveform_pointers[(ref_begin+j)*num_splits + k]++; SDF_split = ( delay_pointer_end[ref_begin+j] - delay_pointer_start[ref_begin+j] )/4 ;
		  xMask_temp = xMask & ( ~(uint8_t(1) << j)) ;												 
          if ( (((new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] ] & 0xC0000000) >> 30) == 0 ) ||
		       (((new_waveforms_total[ waveform_pointers[(ref_begin+j)*num_splits  + k] - 1 ] & 0xC0000000) >> 30) == 1 ) ) {
            if (xMask_temp == 0) {								  
             delay_used_rise = min( delay_used_rise, full_delays[ delay_pointer_start[ref_begin+j] + ( 1 * SDF_split ) + gate_LUT_col2 ] ) ;
             delay_used_fall = min( delay_used_fall, full_delays[ delay_pointer_start[ref_begin+j] + ( 3 * SDF_split ) + gate_LUT_col2 ] ) ;
           } else {
             delay_used_rise = min( delay_used_rise, X_delays[ XCond_pointers[ref_begin+j]*4 + 1 ] ) ;
             delay_used_fall = min( delay_used_fall, X_delays[ XCond_pointers[ref_begin+j]*4 + 3 ] ) ;
           }
         } else {
            if ( xMask_temp == 0 ) {
             delay_used_rise = min( delay_used_rise, full_delays[ delay_pointer_start[ref_begin+j] + ( 0 * SDF_split ) + gate_LUT_col2 ] ) ;
             delay_used_fall = min( delay_used_fall, full_delays[ delay_pointer_start[ref_begin+j] + ( 2 * SDF_split ) + gate_LUT_col2 ] ) ;
            } else {
             delay_used_rise = min( delay_used_rise, X_delays[ XCond_pointers[ref_begin+j]*4 + 0 ] ) ;
             delay_used_fall = min( delay_used_fall, X_delays[ XCond_pointers[ref_begin+j]*4 + 2 ] ) ;
            }
         }
        }
      }
      y = out_tables_cp[celltypes[i]*6561 + gate_LUT_col] ;
      if ( (y==0) && (init_val != 0) && (delay_used_fall != 999000) ||
           (y!=1) && (init_val == 1) && (delay_used_fall != 999000) ||
           (y==1) && (init_val != 1) && (delay_used_rise != 999000) ||
           (y!=0) && (init_val == 0) && (delay_used_rise != 999000) ) {
		delay_used =  ((init_val == 0) || (y == 1)) ? delay_used_rise : delay_used_fall;
        output_trans_time = trans_time + delay_used;
        if ( (output_trans_time  < (delay_used + init_time)) && (((init_val2 != 2) && (init_val != 2) && (y != 2) ) || ( (init_val2 == y))) ) {
          output_p--; init_time = init_time2; init_val = init_val2;
		} else if ( (output_trans_time  < (delay_used + init_time)) && (init_val2 != y) ) {
         init_time = output_trans_time; init_val = y; new_waveforms_total[output_p] = output_trans_time | (uint32_t(y) << 30) ;
        } else {
          output_p++; init_time2 = init_time ; init_time = output_trans_time; 
		  init_val2 = init_val; init_val=y; 
          new_waveforms_total[output_p] = output_trans_time | (uint32_t(y) << 30) ;
        }
      }
	}
  }
  output_p++;
  new_waveforms_total[output_p] = end_token;
  output_pointers[i*num_splits + k] = output_p;
}
}
'''
simulate_gate_GATSPI=cp.RawKernel(kernel_src_code, 'simulate_gate_GATSPI', options=('-lineinfo',), backend='nvcc')
simulate_gate_GATSPI.compile() ;




kernel_src_code = r'''
extern "C" __global__
void simulate_reg2combo_interfaceBlockSync( 
const int* src_node_read_addresses,
const int* bg_node_write_addresses,
const int* next_stage_write_addresses_list,
const int* next_stage_write_stage_list,
const int8_t* pin_positions_list,
int8_t* current_logic_value,  
int8_t* register_combo_interface_previous_states,
const int* edge_breakpoints,
int* theres_an_event,
int* per_thread_msg,
const int num_nodes_this_stage) {
const int i = blockDim.x * blockIdx.x + threadIdx.x;
if ( i<num_nodes_this_stage  ) {
  int8_t value_change = current_logic_value[src_node_read_addresses[i]] - register_combo_interface_previous_states[i]; //current_logic_value is still old value rn.
  if ( value_change != 0 ) {
    register_combo_interface_previous_states[i]=current_logic_value[src_node_read_addresses[i]];
	int node_ref_begin = bg_node_write_addresses[i];
    int edge_anchor = edge_breakpoints[node_ref_begin];
    int num_of_FOs = edge_breakpoints[node_ref_begin+1] -edge_anchor ;
    for(int k=0; k < num_of_FOs; k++) {
      int write_stage = next_stage_write_stage_list[edge_anchor+k] ;
      theres_an_event[write_stage]=1;
      int write_address = next_stage_write_addresses_list[edge_anchor+k];
      int pin_position = int(pin_positions_list[edge_anchor+k]);
      int msg=0;
      msg = ( msg | (1 << 24) ) ;
      msg = (value_change < 0) ? ( msg | (1 << (pin_position*3+2)) ) : msg ;
      msg = (value_change%2==0) ? ( msg | (1 << (pin_position*3+1)) ) : ( msg | (1 << (pin_position*3)) ) ;
      atomicOr(&per_thread_msg[write_address], msg);
    }
  }
}
}
'''
simulate_reg2combo_interfaceBlockSync=cp.RawKernel(kernel_src_code, 'simulate_reg2combo_interfaceBlockSync',backend='nvcc', options=('-lineinfo',))
simulate_reg2combo_interfaceBlockSync.compile() ;

kernel_src_code = r'''
extern "C" __global__
void simulate_stage3dBlockSync( 
const int* next_stage_write_addresses_list,
const int* next_stage_write_stage_list,
const int8_t* pin_positions_list,
int8_t* current_logic_value_thread_blocks, 
int8_t* current_logic_value,
int* endpoint_translation_list,
const int8_t* logics, 
const int* node_breakpoints_start,
const int* edge_breakpoints,
const int* combo_celltypes_list,
int* theres_an_event,
const int* per_stage_num_of_nodes,
int* per_thread_msg,
int* gate_LUT_col_state,
const int* per_part_stage_offsets,
const int threads_per_block, const int no_write_node_num) {
const int i = threadIdx.x;  
const int kk = blockIdx.x;
int stage_anchor = per_part_stage_offsets[kk]; int total_stages = per_part_stage_offsets[kk+1] - stage_anchor;
for (int stage=1; stage < total_stages; stage++) {
  int true_stage = stage_anchor + stage;
  if ( theres_an_event[true_stage] ) { 
    int node_position = i;
    while ( node_position < per_stage_num_of_nodes[true_stage] ) {
      int node_ref_begin = 0; node_ref_begin = (node_breakpoints_start[true_stage]+node_position);
      int node_info = per_thread_msg[node_ref_begin]; 
      bool per_thread_on_or_off = bool((node_info & ( 1 << 24 )) >> 24) ;
      if ( per_thread_on_or_off ) {
        int gate_LUT_col_change = 0; int8_t evaluated_value, value_change; int three_pow=1; int pin_value=0;
        for(int k=0; k<8;k++) {
          pin_value = (((node_info & ( 1 << k*3 )) >> k*3) + 2*((node_info & ( 1 << (k*3+1) )) >> (k*3+1))) ;
          pin_value = ((node_info & ( 1 << (k*3+2) )) >> (k*3+2)) ? -1*pin_value : pin_value;
          gate_LUT_col_change += pin_value*three_pow; three_pow*=3;
        }
        per_thread_msg[node_ref_begin] =0;
        gate_LUT_col_state[node_ref_begin] += gate_LUT_col_change; 
        evaluated_value = logics[6561 * combo_celltypes_list[node_ref_begin] + gate_LUT_col_state[node_ref_begin]] ;
        value_change = evaluated_value - current_logic_value_thread_blocks[node_ref_begin]; //current_logic_value is still old value rn.
        if ( value_change != 0 ) {
          //theres_an_event[map_to_original_logic_stages[stage]]=1;
          current_logic_value_thread_blocks[node_ref_begin] = evaluated_value;
		  if ( endpoint_translation_list[node_ref_begin] != no_write_node_num ) {
            current_logic_value[endpoint_translation_list[node_ref_begin]] = evaluated_value;
          }
          int edge_anchor = edge_breakpoints[node_ref_begin];
          int num_of_FOs = edge_breakpoints[node_ref_begin+1] -edge_anchor ;
          for(int k=0; k < num_of_FOs; k++) {
            int write_stage = next_stage_write_stage_list[edge_anchor+k] ;
            theres_an_event[write_stage]=1;
            int write_address = next_stage_write_addresses_list[edge_anchor+k];
            int pin_position = int(pin_positions_list[edge_anchor+k]);
            int msg=0;
            msg = ( msg | (1 << 24) ) ;
            msg = (value_change < 0) ? ( msg | (1 << (pin_position*3+2)) ) : msg ;
            msg = (value_change%2==0) ? ( msg | (1 << (pin_position*3+1)) ) : ( msg | (1 << (pin_position*3)) ) ;
            atomicOr(&per_thread_msg[write_address], msg);
          }
        }
      }
	  node_position += threads_per_block;
    }
  }
  __syncthreads();
}
}
'''
simulate_stage3dBlockSync=cp.RawKernel(kernel_src_code, 'simulate_stage3dBlockSync', options=('-lineinfo',),backend='nvcc')
simulate_stage3dBlockSync.compile(log_stream=sys.stdout) ;

kernel_src_code = r'''
extern "C" __global__ void setClocks( 
const int8_t* input_values_array,
int8_t* current_logic_value,
const int* clk_node_nums,
const int* clk_input_values_array_indexes,
const int numClocks, const int cycles_input, const int cc) {
const int i = blockDim.x * blockIdx.x + threadIdx.x;
if ( i < numClocks ) {
 current_logic_value[clk_node_nums[i]] = input_values_array[clk_input_values_array_indexes[i]*cycles_input + cc];
}
} 
'''
setClocks=cp.RawKernel(kernel_src_code, 'setClocks', options=('-lineinfo',),backend='nvcc')
setClocks.compile(log_stream=sys.stdout) ;

kernel_src_code = r'''
extern "C" __global__ void zeroOut( 
int* theres_an_event,
const int theres_an_eventShape0) {
const int i = blockDim.x * blockIdx.x + threadIdx.x;
if ( i < theres_an_eventShape0 ) {
 theres_an_event[i] = 0;
}
}
'''
zeroOut=cp.RawKernel(kernel_src_code, 'zeroOut', options=('-lineinfo',),backend='nvcc')
zeroOut.compile(log_stream=sys.stdout) ;


kernel_src_code = r'''
#include <stdint.h>				   
extern "C" __global__
void set_input_array( 
const int64_t* new_waveforms_total,
const int8_t* new_waveforms_values_total,
const int64_t* pointers, 
int8_t* input_values_array,
const bool* sync_or_async_event_processed,
const int8_t* signal_type,
const int64_t* input_event_queue,
const int change_list_size, const int nodes_size) {
  const int i = blockDim.x * blockIdx.x + threadIdx.x;
  if (i < nodes_size ) {
    int64_t Timechange, Timechange_next; int Timechange_pointer; int64_t cond_pointer_offset = 0;
    Timechange_pointer = 0 ;
    Timechange = input_event_queue[Timechange_pointer] ;
    while (Timechange_pointer != change_list_size) {
        if ( (signal_type[i]>0) || (sync_or_async_event_processed[Timechange_pointer]==1) ) { //special clk signals
          while ( new_waveforms_total[pointers[i] + cond_pointer_offset] <= Timechange ) {
            cond_pointer_offset++;
          }
        } else { //normal signal types
         Timechange_next = input_event_queue[Timechange_pointer+1];
          while ( new_waveforms_total[pointers[i] + cond_pointer_offset] < Timechange_next ) {
            cond_pointer_offset++;
          }
        }
      input_values_array[(i*change_list_size) + Timechange_pointer] = new_waveforms_values_total[pointers[i] + cond_pointer_offset -1 ]  ;
      if ( (signal_type[i] ==2) && (sync_or_async_event_processed[Timechange_pointer]==1) &&
           (Timechange != new_waveforms_total[pointers[i] + cond_pointer_offset-1]) &&
           (new_waveforms_values_total[pointers[i] + cond_pointer_offset -1 ]==1) ) {
          input_values_array[(i*change_list_size) + Timechange_pointer] = 3  ;
      }
      Timechange_pointer++;     Timechange = input_event_queue[Timechange_pointer] ;
    }
  }
}
'''
set_input_array=cp.RawKernel(kernel_src_code, 'set_input_array', backend='nvcc')
set_input_array.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <math.h>
extern "C" __global__ void simulateSequentialStage( 
int8_t* current_logic_value,
uint64_t* output_waveforms_storage,
const int* first_level_inputs_seq_list,
const int* cell_types_seq_list,
const int* seq_nodes_list,
const int* node_breakpoints_seq_start,
const int8_t* seq_logics,
const int64_t* temp_active_timestamps,
uint32_t* global_vc_write_pointer,
const uint32_t* pushout_delays,
uint32_t* numOfSwitchesPerDriverPerSplit,
const int stage, const int cycle, const int nodes_size, const int num_splits, const uint64_t fold_split) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < nodes_size ) {
int node_ref_begin = (node_breakpoints_seq_start[stage]+i); int node_num = seq_nodes_list[node_ref_begin]; int8_t previousValue = current_logic_value[node_num] ;
int8_t SDN = 1 ; int8_t CDN = 1 ; int8_t  CP = 1 ; int8_t SE = 0 ; int8_t SI = 0 ; int8_t D = 0 ; int8_t ENABLE = 1 ; int8_t newValue;
if ( ( cell_types_seq_list[node_ref_begin] < 300 ) && (cell_types_seq_list[node_ref_begin] >= 200) ) { //it's a flop we are  simulating
 D = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] ; 
 SI = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+1 ]] ; 
 SE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+2 ]] ; 
 ENABLE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+3 ]] ; 
 SDN = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+4 ]] ; 
 CDN = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+5 ]] ; 
 CP = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+6 ]] ; CP = (CP == 3) ? 0 : CP ;
 int8_t effD = ENABLE == 1 ? D : ENABLE == 0 ? previousValue : 2; effD = SE == 1 ? SI : SE == 0 ? effD : 2;
 if (cell_types_seq_list[node_ref_begin] & 1) {
  CP= (CP == 2) ? 2 :
      (CP == 1) ? 0 : 1;
 }
 //current_logic_value[seq_nodes_list[node_ref_begin]] = ( ~SDN | ( ( CP & ( (SI & SE) | (~SE & D & ENABLE) | (~SE & ~ENABLE & previous_states[node_ref_begin]) ) ) | (~CP & previous_states[node_ref_begin]) ) ) & CDN ;
 //((previousValue==2) && (CP != 1)) ? 0 :
 //((effD==2) && (previousValue==1)) ? 1 :
 //(effD==2) ? 0 : 
 newValue = (CDN==0) ? 0 : 
            (SDN==0 && CDN==1) ? 1 :
            (SDN==2 && CDN==1) ? 2 :
            seq_logics[int(CP)+int(previousValue)*3 + int(SI)*9+int(SE)*27+int(ENABLE)*81+int(D)*243+int(SDN)*729+int(CDN)*2187] ;
 if (cell_types_seq_list[node_ref_begin] & 2) {
  newValue = (newValue==2) ? 2:
             (newValue==1) ? 0 : 1;
 }
} else if ( ( cell_types_seq_list[node_ref_begin] < 400 ) && (cell_types_seq_list[node_ref_begin] >= 200) ) { //it's a clk gate we are  simulating
 int8_t TD = 0 ; int8_t TE = 0;
 D = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] ; 
 SI = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+1 ]];
 SE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+2 ]] ;   
 TD = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+5 ]] ; 
 SDN = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+4 ]] ; 																						  
 TE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+7 ]] ; 																						 
 CP = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+6 ]] ;  CP = (CP == 3) ? 1 : CP ;
 if (cell_types_seq_list[node_ref_begin] & 1) {
  CP= (CP == 2) ? 2 :
  (CP == 1) ? 0 : 1;
 }
 //current_logic_value[seq_nodes_list[node_ref_begin]] = ~SDN | ( ( ( ( ~TD & ( (SI & SE) | (~SE & D) ) ) | TE ) & CP ) | (~CP & previous_states[node_ref_begin]) ) ;
 newValue = SDN==0 ? 1 :
            SDN==1 && CDN==0 ? 0 :
            seq_logics[6561+int(CP)+int(previousValue)*3+int(TE)*9+int(TD)*27+int(SI)*81+int(SE)*243+int(D)*729+int(SDN)*2187] ;
 if (cell_types_seq_list[node_ref_begin] & 2) {
  newValue = (newValue==2) ? 2:
             (newValue==1) ? 0 : 1;
 }
} else if ( ( cell_types_seq_list[node_ref_begin] >= 400 ) && (cell_types_seq_list[node_ref_begin] < 500) ) { //it's a latch, different rules
 int8_t TD = 0 ; int8_t TE = 0;
 D = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] ; 
 SI = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+1 ]];
 SE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+2 ]] ;   
 TD = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+5 ]] ; 
 SDN = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+4 ]] ; 
 TE = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+7 ]] ; 
 CP = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+6 ]] ;  CP = (CP== 3) ? 1 : CP ;
 if (cell_types_seq_list[node_ref_begin] & 1) {
  CP= (CP == 2) ? 2 :
  (CP == 1) ? 0 : 1;
 }
 //current_logic_value[seq_nodes_list[node_ref_begin]] = ~SDN | ( ( ( ( ~TD & ( (SI & SE) | (~SE & D) ) ) | TE ) & CP ) | (~CP & previous_states[node_ref_begin]) ) ;
 newValue = SDN==0 ? 1 :
            SDN==1 && CDN==0 ? 0 :
            seq_logics[13122+int(CP)+int(previousValue)*3+int(TE)*9+int(TD)*27+int(SI)*81+int(SE)*243+int(D)*729+int(SDN)*2187] ;
 if (cell_types_seq_list[node_ref_begin] & 2) {
  newValue = (newValue==2) ? 2:
             (newValue==1) ? 0 : 1;
 }
} else if (cell_types_seq_list[node_ref_begin] == 21 ) { newValue = current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] ; } 
else if (  cell_types_seq_list[node_ref_begin] == 24 ) { newValue = (current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] == 2) ? 2 : (current_logic_value[first_level_inputs_seq_list[ node_ref_begin*8+0 ]] == 0) ? 1 : 0 ; } 
//finally, write results to output_waveforms_storage
current_logic_value[node_num] = newValue;
if (previousValue != newValue) {	  
 uint64_t vc_point =uint64_t(temp_active_timestamps[cycle]);
 uint64_t pushout_delay = newValue==0 ? uint64_t(pushout_delays[node_ref_begin] & 0x0000FFFF) :
                          newValue==1 ? uint64_t((pushout_delays[node_ref_begin] & 0xFFFF0000) >> 16) :
                          previousValue==0 ? uint64_t((pushout_delays[node_ref_begin] & 0xFFFF0000) >> 16) : uint64_t(pushout_delays[node_ref_begin] & 0x0000FFFF) ;
 vc_point += pushout_delay; int split = int(vc_point / fold_split);  numOfSwitchesPerDriverPerSplit[node_ref_begin*num_splits + split]++ ; 
 vc_point = vc_point | (uint64_t(newValue) << 62) ;
 vc_point = vc_point | (uint64_t(node_num) << 32) ; 
 uint32_t vc_point_write_address = atomicAdd(&global_vc_write_pointer[0],1);
 output_waveforms_storage[vc_point_write_address] = vc_point;
}
}
}
'''
simulateSequentialStage=cp.RawKernel(kernel_src_code, 'simulateSequentialStage',backend='nvcc', options = ('-lineinfo',))
simulateSequentialStage.compile() ;


kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__ void createCompactOutTables( 
const int8_t* outs,
const int* byteAddressTensor,
const int* bitAddressTensor,
uint32_t* compactOutTables,
const int elements) {
const int i = blockIdx.x * blockDim.x + threadIdx.x ;
if ( i < elements ) {
  uint32_t msg = uint32_t(outs[i]); int writeAddress = byteAddressTensor[i];
  msg = msg << (2*bitAddressTensor[i]) ;
  atomicOr(&compactOutTables[writeAddress], msg);
}
}
'''
createCompactOutTables=cp.RawKernel(kernel_src_code, 'createCompactOutTables',backend='nvcc')
createCompactOutTables.compile() ;


kernel_src_code = r'''
extern "C" __global__ void zeroOutConstantMemory( 
int8_t* theres_an_event,
const int theres_an_eventShape0) {
const int i = blockDim.x * blockIdx.x + threadIdx.x;
if ( i < theres_an_eventShape0 ) {
 theres_an_event[i] = 0;
}
}
'''
zeroOutConstantMemory=cp.RawKernel(kernel_src_code, 'zeroOutConstantMemory', options=('-lineinfo',),backend='nvcc')
zeroOutConstantMemory.compile(log_stream=sys.stdout) ;



simulateLogicCode = r'''
#include <stdint.h>
#include <math.h>
extern "C" { 
__constant__ int per_part_stage_offsets[PARTS];
__constant__ uint32_t logics[LOGIC_LENGTH];
__constant__ int level0Offsets[PARTS + 1];
__constant__ int three_pow[8]; //1, 3, 9, 27, 81, 243, 729, 2187

__global__ void simulate_stage3dBlockSyncConstantMemory( 
uint32_t* edgeWriteInfo, 
int8_t* current_logic_valueOld,
int* endpoint_translation_list, 
int* node_breakpoints_start,
int* nodeWriteInfo,
int* combo_celltypes_list,
int* per_thread_msg,
int* src_node_read_addresses,
int8_t* register_combo_interface_previous_states,
int* edge_breakpoints,
int threads_per_block) {
const int i = threadIdx.x;  
const int kk = blockIdx.x;

int node_position;
int stage_anchor = per_part_stage_offsets[kk]; int total_stages = per_part_stage_offsets[kk+1] - stage_anchor;
extern __shared__ int s[];
int* theresAnEvent = s;
int* nodeBreakpointsStart = (int*)&theresAnEvent[total_stages+1];

if (i < (total_stages+1)) { 
 theresAnEvent[i] = 0; 
 nodeBreakpointsStart[i] = node_breakpoints_start[stage_anchor+i];
} 
__syncthreads();



int num_nodes_this_stage0 = level0Offsets[kk+1] ;
node_position = i + level0Offsets[kk];
while ( node_position<num_nodes_this_stage0  ) {
  int8_t value_change = current_logic_valueOld[src_node_read_addresses[node_position]] - register_combo_interface_previous_states[node_position]; //current_logic_value is still old value rn.
  if ( value_change != 0 ) {
    register_combo_interface_previous_states[node_position]=current_logic_valueOld[src_node_read_addresses[node_position]]; 
    int node_ref_begin = (nodeBreakpointsStart[0]+node_position - level0Offsets[kk]);
    int edge_anchor = edge_breakpoints[node_ref_begin];
    int num_of_FOs = edge_breakpoints[node_ref_begin+1] -edge_anchor ;
    for(int k=0; k < num_of_FOs; k++) {
     uint32_t edgeInfo = edgeWriteInfo[edge_anchor+k];
     uint32_t write_stage = ((edgeInfo &  0xFE000000) >> 25) ;
     theresAnEvent[write_stage]=1;
     uint32_t write_address = ((edgeInfo & 0x01FFFFF8) >> 3) ;
     uint32_t pin_position = edgeInfo & 0x00000007;
     atomicOr(&per_thread_msg[write_address], 0x00008000);
     atomicAdd(&per_thread_msg[write_address], int(value_change)*three_pow[pin_position]);
    }
  }
node_position += threads_per_block;
}
__syncthreads();



for (int stage=1; stage < total_stages; stage++) {
  //int true_stage = stage_anchor + stage; 
  if ( theresAnEvent[stage] ) { 
    int nodesThisStage = nodeBreakpointsStart[stage+1] - nodeBreakpointsStart[stage]; node_position = i;
    while ( node_position < nodesThisStage ) {
      int node_ref_begin = (nodeBreakpointsStart[stage]+node_position);
      int node_info = per_thread_msg[node_ref_begin] & 0x0000FFFF  ;
      bool per_thread_on_or_off = bool((node_info & 0x00008000 ) >> 15) ;
      if ( per_thread_on_or_off ) {
        int evaluated_value, value_change;
		int current_logic_value = ((node_info & 0x00006000) >> 13) ;
        int gate_LUT_col = node_info & 0x00001FFF ; 
        int comboCelltypeOffset = (combo_celltypes_list[node_ref_begin>>1] & (0x0000FFFF << (16*(node_ref_begin%2)))) >> (16*(node_ref_begin%2)) ;
        evaluated_value = ((logics[comboCelltypeOffset + (gate_LUT_col>>4)]  &  ( 0x00000003 << (2*(gate_LUT_col % 16)) )) >> (2*(gate_LUT_col % 16))) ;
        value_change = evaluated_value - current_logic_value; //current_logic_value is still old value rn.
		if ( value_change == 0 ) {
          per_thread_msg[node_ref_begin] = (node_info) & 0xFFFF7FFF ;
		} else {
          per_thread_msg[node_ref_begin] = ((node_info & 0xFFFF1FFF) | ( (evaluated_value) << 13));
          node_info = nodeWriteInfo[node_ref_begin] ; 
          int translateOrNot = node_info & 0x80000000 ; 
          int num_of_FOs = (node_info & 0x7C000000) >> 26 ; 
          int edge_anchor = node_info & 0x03FFFFFF ;
		  if ( translateOrNot != 0 ) {
            current_logic_valueOld[endpoint_translation_list[node_ref_begin]] = int8_t(evaluated_value);
          }
          for(int k=0; k < num_of_FOs; k++) {
            uint32_t edgeInfo = edgeWriteInfo[edge_anchor+k];
            uint32_t write_stage = ((edgeInfo &  0xFE000000) >> 25) ;
            theresAnEvent[write_stage]=1;
            uint32_t write_address = ((edgeInfo & 0x01FFFFF8) >> 3)  ;
            uint32_t pin_position = edgeInfo & 0x00000007;
            atomicOr(&per_thread_msg[write_address], 0x00008000);
            atomicAdd(&per_thread_msg[write_address], (value_change)*three_pow[pin_position]);
          }
        }
      }
	  node_position += threads_per_block;
    }
  }
  __syncthreads();
}
}

}
'''



kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateSAIF( 
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
uint64_t* T0T1TXTimes,
const int num_splits, const int num_nodes, const uint32_t fold_split, const uint64_t sim_duration, const int subchunk_id) {
const int threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const int i = (threadID / num_splits) ; const int k = (threadID % num_splits) ;
if ( i < num_nodes  ) {
 uint64_t extracted_value, extracted_time, current_time, current_value, second_value, endOfSplit; uint32_t vc;
 int search_split = k-1;
 while ( search_split >= 0 ) {
  if ( (perNodePerSplitWaveformPointerEnd[i*num_splits + search_split] - perNodePerSplitWaveformPointerStart[i*num_splits + search_split]) > 2 ) {
   break;
  } else {
   search_split--;
  }
 }
 if (search_split >= 0 ) {
   vc = new_waveforms_total[ perNodePerSplitWaveformPointerEnd[ i*num_splits + search_split ] - 3 ] ;
   second_value = uint64_t((vc & 0xC0000000) >> 30);
 }
 int64_t thisGATSPIPointerCurrent = perNodePerSplitWaveformPointerStart[i*num_splits+k];
 int64_t thisGATSPIPointerEnd = perNodePerSplitWaveformPointerEnd[i*num_splits+k];
 uint64_t timeOffset = uint64_t(uint64_t(fold_split) * uint64_t(k));
 endOfSplit = (k==31) ? sim_duration : timeOffset + uint64_t(fold_split);
 vc = new_waveforms_total[ thisGATSPIPointerCurrent ] ;
 current_value  = uint64_t((vc & 0xC0000000) >> 30); current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 second_value = search_split < 0 ? current_value : second_value;
 extracted_value = current_value ; extracted_time = current_time;
 thisGATSPIPointerCurrent++;
 for (int64_t j = thisGATSPIPointerCurrent ; j < (thisGATSPIPointerEnd-1) ; j++ ) {
  vc = new_waveforms_total[ j ] ;
  extracted_value  = uint64_t((vc & 0xC0000000) >> 30); extracted_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += extracted_time - current_time ; 
  if ((current_value == 2) && (second_value == extracted_value)) { T0T1TXTimes[i*5*num_splits + k*5 + 4 ]++ ;}
  else if ((current_value == 2) && (second_value != extracted_value) && (second_value != 2) ) { T0T1TXTimes[i*5*num_splits + k*5 + 3 ]++ ;}
  else if ( (extracted_value != 2) && !((second_value == 2) && (second_value == current_value)) ) { T0T1TXTimes[i*5*num_splits + k*5 + 3 ]++ ;}
  second_value = current_value; current_value  = extracted_value; current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 }
 //Add the last switch to fold_split T0, T1, TX values.
  T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += endOfSplit - current_time ; 
}
}
'''
calculateSAIF=cp.RawKernel(kernel_src_code, 'calculateSAIF', backend='nvcc')
calculateSAIF.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <iostream>
#include <algorithm>
#include <math.h>
extern "C" __global__ void calculateSAIFLastSubchunk( 
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
uint64_t* T0T1TXTimes,
const int num_splits, const int num_nodes, const uint32_t fold_split, 
const int subchunk_id, const uint64_t totalSimDuration, const uint64_t subchunkStartTime) {
const int threadID = blockIdx.x * blockDim.x + threadIdx.x ;
const int i = (threadID / num_splits) ; const int k = (threadID % num_splits) ;
if ( i < num_nodes  ) {
 uint64_t extracted_value, extracted_time, current_time, current_value, second_value, endOfSplit; uint32_t vc;
 int search_split = k-1;
 while ( search_split >= 0 ) {
  if ( (perNodePerSplitWaveformPointerEnd[i*num_splits + search_split] - perNodePerSplitWaveformPointerStart[i*num_splits + search_split]) > 2 ) {
   break;
  } else {
   search_split--;
  }
 }
 if (search_split >= 0 ) {
   vc = new_waveforms_total[ perNodePerSplitWaveformPointerEnd[ i*num_splits + search_split ] - 3 ] ;
   second_value = uint64_t((vc & 0xC0000000) >> 30);
 }
 int64_t thisGATSPIPointerCurrent = perNodePerSplitWaveformPointerStart[i*num_splits+k];
 int64_t thisGATSPIPointerEnd = perNodePerSplitWaveformPointerEnd[i*num_splits+k];
 uint64_t timeOffset = uint64_t(uint64_t(fold_split) * uint64_t(k));
 endOfSplit = (k==31) ? totalSimDuration : timeOffset + uint64_t(fold_split);
 timeOffset = (k==31) ? timeOffset + subchunkStartTime : timeOffset;
 vc = new_waveforms_total[ thisGATSPIPointerCurrent ] ;
 current_value  = uint64_t((vc & 0xC0000000) >> 30); current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
 second_value = search_split < 0 ? current_value : second_value;
 extracted_value = current_value ; extracted_time = current_time;
 thisGATSPIPointerCurrent++;
 for (int64_t j = thisGATSPIPointerCurrent ; j < (thisGATSPIPointerEnd-1) ; j++ ) {
  vc = new_waveforms_total[ j ] ;
  extracted_value  = uint64_t((vc & 0xC0000000) >> 30); extracted_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  if ( extracted_time < totalSimDuration ) {
   T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += extracted_time - current_time ; 
   if ((current_value == 2) && (second_value == extracted_value)) { T0T1TXTimes[i*5*num_splits + k*5 + 4 ]++ ;}
   else if ((current_value == 2) && (second_value != extracted_value) && (second_value != 2) ) { T0T1TXTimes[i*5*num_splits + k*5 + 3 ]++ ;}
   else if ( (extracted_value != 2) && !((second_value == 2) && (second_value == current_value)) ) { T0T1TXTimes[i*5*num_splits + k*5 + 3 ]++ ;}
   second_value = current_value; current_value  = extracted_value; current_time = uint64_t(vc & 0x3FFFFFFF) + timeOffset ;
  }
 }
 //Add the last switch to fold_split T0, T1, TX values.
  T0T1TXTimes[i*5*num_splits + k*5 + int(current_value) ] += endOfSplit - current_time ; 
}
}
'''
calculateSAIFLastSubchunk=cp.RawKernel(kernel_src_code, 'calculateSAIFLastSubchunk', backend='nvcc')
calculateSAIFLastSubchunk.compile() ;

kernel_src_code = r'''
#include <stdint.h>
#include <algorithm>
extern "C" __global__
void adjustClkTreeSAIFLastSubchunk( 
const int* nodeNums,
const uint32_t* pushout_delays,
uint64_t* T0s, 
uint64_t* T1s,
uint64_t* TCs,
const int8_t* polarityToSrc,
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
const int nodes_size, const uint64_t period, const uint64_t firstEdge, const int numSplits, const uint64_t simSubchunkDuration) {
const int i = blockDim.x * blockIdx.x + threadIdx.x;
if ( i < nodes_size ) {

uint32_t firstValue, lastValue, vc; 
vc = new_waveforms_total[ perNodePerSplitWaveformPointerStart[ i*numSplits ] ] ;
firstValue  = (vc & 0xC0000000) >> 30 ;
vc = new_waveforms_total[ perNodePerSplitWaveformPointerEnd[ i*numSplits + numSplits - 1 ] - 1 ] ;
lastValue  = (vc & 0xC0000000) >> 30 ;

uint64_t SAIFValue = polarityToSrc[i] ? T0s[nodeNums[i]] : T1s[nodeNums[i]] ;
uint64_t pushout1, pushout2;
pushout1 = polarityToSrc[i] ? uint64_t(pushout_delays[i] & 0x0000FFFF) : uint64_t((pushout_delays[i] & 0xFFFF0000) >> 16) ; 
pushout2 = polarityToSrc[i] ? uint64_t((pushout_delays[i] & 0xFFFF0000) >> 16) : uint64_t(pushout_delays[i] & 0x0000FFFF) ;
uint64_t howFarLastEdge = (simSubchunkDuration - firstEdge - pushout1) % period ; //1968
uint64_t subDuration = int8_t(lastValue) !=  polarityToSrc[i] ? SAIFValue - howFarLastEdge : SAIFValue;
uint64_t timesTurnedOff = (TCs[nodeNums[i]] + uint64_t(firstValue%2)) >> 1;
uint64_t cycles =  pushout2 > pushout1 ? ( (subDuration -  (pushout2 - pushout1)*timesTurnedOff ) / period ) : ((subDuration +  (pushout1 - pushout2)*timesTurnedOff ) / period) ;
SAIFValue = cycles * ( (period >> 1) - pushout1 + pushout2);
uint64_t otherSAIFValueAddition=0;
if (int8_t(lastValue) !=  polarityToSrc[i]) {
 SAIFValue += min(howFarLastEdge, (period>>1) - pushout1 + pushout2) ;
 otherSAIFValueAddition = howFarLastEdge > ((period>>1) - pushout1 + pushout2) ? (howFarLastEdge - ((period>>1) - pushout1 + pushout2)) : 0 ;
 TCs[nodeNums[i]] = howFarLastEdge >= ((period>>1) - pushout1 + pushout2) ? cycles*2 + 2  : cycles*2 + 1;
} else {
 TCs[nodeNums[i]] = cycles*2 ;
}
uint64_t otherSAIFValueAddition2 = pushout2 > pushout1 ? timesTurnedOff* (pushout2 - pushout1) : timesTurnedOff* (pushout1 - pushout2); 
if (polarityToSrc[i]) {
  T0s[nodeNums[i]] = SAIFValue ;
  T1s[nodeNums[i]] += pushout2 > pushout1 ? cycles* ((period >> 1) + pushout1 - pushout2) + otherSAIFValueAddition + otherSAIFValueAddition2 : cycles* ((period >> 1) + pushout1 - pushout2) + otherSAIFValueAddition - otherSAIFValueAddition2;
} else {
  T1s[nodeNums[i]] = SAIFValue ;
  T0s[nodeNums[i]] += pushout2 > pushout1 ? cycles* ((period >> 1) + pushout1 - pushout2) + otherSAIFValueAddition + otherSAIFValueAddition2 : cycles* ((period >> 1) + pushout1 - pushout2) + otherSAIFValueAddition - otherSAIFValueAddition2;
}

}
}
'''
adjustClkTreeSAIFLastSubchunk=cp.RawKernel(kernel_src_code, 'adjustClkTreeSAIFLastSubchunk', backend='nvcc')
adjustClkTreeSAIFLastSubchunk.compile() ;

kernel_src_code = r'''
#include <stdint.h>
extern "C" __global__
void adjustClkTreeSAIF( 
const int* nodeNums,
const uint32_t* pushout_delays,
uint64_t* T0s, 
uint64_t* T1s,
uint64_t* TCs,
const int8_t* polarityToSrc,
const uint32_t* new_waveforms_total,
const int64_t* perNodePerSplitWaveformPointerStart,
const int64_t* perNodePerSplitWaveformPointerEnd,
const int nodes_size, const uint64_t period, const uint64_t firstEdge, const int numSplits, const uint64_t simSubchunkDuration) {
const int i = blockDim.x * blockIdx.x + threadIdx.x;
if ( i < nodes_size ) {

uint32_t firstValue, lastValue, vc; 
vc = new_waveforms_total[ perNodePerSplitWaveformPointerStart[ i*numSplits ] ] ;
firstValue  = (vc & 0xC0000000) >> 30 ;
vc = new_waveforms_total[ perNodePerSplitWaveformPointerEnd[ i*numSplits + numSplits - 1 ] - 1 ] ;
lastValue  = (vc & 0xC0000000) >> 30 ;

uint64_t SAIFValue = polarityToSrc[i] ? T0s[nodeNums[i]] : T1s[nodeNums[i]] ;
uint64_t pushout1, pushout2;
pushout1 = polarityToSrc[i] ? uint64_t(pushout_delays[i] & 0x0000FFFF) : uint64_t((pushout_delays[i] & 0xFFFF0000) >> 16) ; 
pushout2 = polarityToSrc[i] ? uint64_t((pushout_delays[i] & 0xFFFF0000) >> 16) : uint64_t(pushout_delays[i] & 0x0000FFFF) ;
uint64_t howFarLastEdge = (simSubchunkDuration - firstEdge - pushout1) % period ; //1968
uint64_t subDuration = int8_t(lastValue) !=  polarityToSrc[i] ? SAIFValue - howFarLastEdge : SAIFValue;
uint64_t timesTurnedOff = (TCs[nodeNums[i]] + uint64_t(firstValue%2)) >> 1;
uint64_t cycles =  pushout2 > pushout1 ? ( (subDuration -  (pushout2 - pushout1)*timesTurnedOff ) / period ) : ((subDuration +  (pushout1 - pushout2)*timesTurnedOff ) / period) ;

SAIFValue = cycles * ( (period >> 1) - pushout1 + pushout2);
if (int8_t(lastValue) !=  polarityToSrc[i]) {
  cycles++;
}
SAIFValue = cycles * ( (period >> 1) - pushout1 + pushout2);
TCs[nodeNums[i]] = cycles*2 ;
uint64_t otherSAIFValueAddition2 = pushout2 > pushout1 ? timesTurnedOff* (pushout2 - pushout1) : timesTurnedOff* (pushout1 - pushout2); 
if (polarityToSrc[i]) {
  T0s[nodeNums[i]] = SAIFValue ;
  T1s[nodeNums[i]] += pushout2 > pushout1 ? cycles* ((period >> 1) + pushout1 - pushout2) + otherSAIFValueAddition2 : cycles* ((period >> 1) + pushout1 - pushout2) - otherSAIFValueAddition2;
} else {
  T1s[nodeNums[i]] = SAIFValue ;
  T0s[nodeNums[i]] += pushout2 > pushout1 ? cycles* ((period >> 1) + pushout1 - pushout2) + otherSAIFValueAddition2 : cycles* ((period >> 1) + pushout1 - pushout2) - otherSAIFValueAddition2;
}

}
}
'''
adjustClkTreeSAIF=cp.RawKernel(kernel_src_code, 'adjustClkTreeSAIF', backend='nvcc')
adjustClkTreeSAIF.compile() ;
